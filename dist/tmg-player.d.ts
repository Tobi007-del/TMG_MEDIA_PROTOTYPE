// Generated by dts-bundle-generator v9.5.1

export type Primitive = string | number | boolean | bigint | symbol | null | undefined;
export type NoTraverse = Primitive | Function | Date | Error | RegExp | Promise<any> | Map<any, any> | WeakMap<any, any> | Set<any> | WeakSet<any> | HTMLElement | Element | Node | EventTarget | Window | Document | AbortSignal | Inert<unknown>;
export type WCPaths<T> = "*" | Paths<T>;
export type Paths<T, S extends string = "."> = T extends NoTraverse ? never : T extends readonly (infer U)[] ? `${Extract<keyof T, number>}` | `${Extract<keyof T, number>}${S}${Paths<U, S>}` : {
	[K in keyof T & (string | number)]: T[K] extends Primitive ? `${K}` : `${K}` | `${K}${S}${Paths<T[K], S>}`;
}[keyof T & (string | number)];
export type PathValue<T, P extends string = Paths<T>, S extends string = "."> = P extends "*" ? T : P extends `${infer K}${S}${infer Rest}` ? K extends keyof T ? PathValue<T[K], Rest, S> : never : P extends keyof T ? T[P] : never;
export type PathParentValue<T, P extends string = Paths<T>> = P extends `${infer Parent}.${infer _Rest}` ? Parent extends "" ? T : PathValue<T, Parent> : T;
// Turns dotted keys into nested objects while preserving value types
export type Unflatten<T extends Record<string, any>, S extends string = "."> = UnionToIntersection<{
	[K in keyof T & string]: UnflattenKey<K, T[K], S>;
}[keyof T & string]>;
export type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;
export type UnflattenKey<K extends string, V, S extends string> = K extends `${infer Head}${S}${infer Tail}` ? {
	[P in Head]: UnflattenKey<Tail, V, S>;
} : {
	[P in K]: V;
};
// "It's not that deep" Warriors
export type DeepMerge<T1, T2> = T2 extends object ? T1 extends object ? {
	[K in keyof T1 | keyof T2]: K extends keyof T2 ? K extends keyof T1 ? DeepMerge<T1[K], T2[K]> : T2[K] : K extends keyof T1 ? T1[K] : never;
} : T2 : T2;
export type DeepPartial<T> = T extends Function ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends object ? {
	[P in keyof T]?: DeepPartial<T[P]>;
} : T;
declare const REJECTABLE: unique symbol;
declare const INERTIA: unique symbol;
declare const TERMINATOR: unique symbol;
declare class Event$1<T, P extends WCPaths<T> = WCPaths<T>> {
	static readonly NONE = 0;
	static readonly CAPTURING_PHASE = 1;
	static readonly AT_TARGET = 2;
	static readonly BUBBLING_PHASE = 3;
	type: Payload<T, P>["type"];
	currentTarget: Payload<T, P>["currentTarget"];
	eventPhase: number;
	readonly staticType: Payload<T, P>["type"];
	readonly target: Payload<T, P>["target"];
	readonly root: Payload<T, P>["root"];
	readonly path: Target<T, P>["path"];
	readonly value: Target<T, P>["value"];
	readonly oldValue: Target<T, P>["oldValue"];
	readonly rejectable: boolean;
	readonly bubbles: boolean;
	private _propagationStopped;
	private _immediatePropagationStopped;
	private _resolved;
	private _rejected;
	constructor(payload: Payload<T, P>, bubbles?: boolean);
	get propagationStopped(): boolean;
	stopPropagation(): void;
	get immediatePropagationStopped(): boolean;
	stopImmediatePropagation(): void;
	get resolved(): string;
	resolve(message?: string): void;
	get rejected(): string;
	reject(reason?: string): void;
	composedPath(): WCPaths<T>[];
}
declare class Reactor<T extends object> {
	private getters;
	private setters;
	private watchers;
	private listenersRecord;
	private batch;
	private isBatching;
	private queue;
	private proxyCache;
	core: T;
	constructor(obj?: T, options?: ReactorOptions);
	private _proxify;
	private _mediate;
	private _notify;
	private _schedule;
	private _initBatching;
	private _flush;
	private _wave;
	private _fire;
	private _getContext;
	private _bind;
	tick(paths?: Paths<T> | Iterable<Paths<T>>): void;
	stall(task: () => any): void;
	nostall(task: () => any): boolean | undefined;
	get<P extends Paths<T>>(path: P, cb: Getter<T, P>, opts?: SyncOptions): Reactor<T>["noget"];
	gonce<P extends Paths<T>>(path: P, cb: Getter<T, P>, opts?: SyncOptions): Reactor<T>["noget"];
	noget<P extends Paths<T>>(path: P, cb: Getter<T, P>): boolean | undefined;
	set<P extends Paths<T>>(path: P, cb: Setter<T, P>, opts?: SyncOptions): Reactor<T>["noset"];
	sonce<P extends Paths<T>>(path: P, cb: Setter<T, P>, opts?: SyncOptions): Reactor<T>["noset"];
	noset<P extends Paths<T>>(path: P, cb: Setter<T, P>): boolean | undefined;
	watch<P extends Paths<T>>(path: P, cb: Watcher<T, P>, opts?: SyncOptions): Reactor<T>["nowatch"];
	wonce<P extends Paths<T>>(path: P, cb: Watcher<T, P>, opts?: SyncOptions): Reactor<T>["nowatch"];
	nowatch<P extends Paths<T>>(path: P, cb: Watcher<T, P>): boolean | undefined;
	on<P extends WCPaths<T>>(path: P, cb: Listener<T, P>, options?: ListenerOptions): Reactor<T>["off"];
	once<P extends WCPaths<T>>(path: P, cb: Listener<T, P>, options?: ListenerOptions): Reactor<T>["off"];
	off<P extends WCPaths<T>>(path: P, cb: Listener<T, P>, options?: ListenerOptions): boolean | undefined;
	cascade({ type, currentTarget: { path, value: news, oldValue: olds } }: Event$1<T>, objSafe?: boolean): void;
	snapshot(): T;
	reset(): void;
	destroy(): void;
}
export type Dataset = Record<string, string | number>;
export type Style = Partial<CSSStyleDeclaration>;
export type Direction = "x" | "y";
export type Position = "before" | "after" | "at";
export type ResourceType = "style" | "script" | string;
export type SafeClickEl = HTMLElement & {
	_clickHandler?: (e: MouseEvent) => void;
	_dblClickHandler?: (e: MouseEvent) => void;
	_clickTimeoutId?: ReturnType<typeof setTimeout>;
};
export interface LoadResourceOptions {
	module?: boolean;
	media?: string;
	crossOrigin?: string;
	integrity?: string;
}
declare function createEl<K extends keyof HTMLElementTagNameMap>(tag: K, props?: Partial<HTMLElementTagNameMap[K]>, dataset?: Dataset, styles?: Style): HTMLElementTagNameMap[K];
declare function createEl(tag: string, props?: Partial<HTMLElement>, dataset?: Dataset, styles?: Style): HTMLElement | null;
declare function assignEl<K extends keyof HTMLElementTagNameMap>(el?: HTMLElementTagNameMap[K], props?: Partial<HTMLElementTagNameMap[K]>, dataset?: Dataset, styles?: Style): void;
declare function assignEl(el?: HTMLElement, props?: Partial<HTMLElement>, dataset?: Dataset, styles?: Style): void;
declare function loadResource(src: string, type?: ResourceType, { module, media, crossOrigin, integrity }?: LoadResourceOptions): Promise<HTMLElement | void>;
declare function inDocView(el: Element, axis?: "x" | "y"): boolean;
declare const getElSiblingAt: (p: number, dir: Direction, els: Element[], pos?: Position) => Element | undefined;
declare const queryFullscreen: () => boolean;
declare const queryFullscreenEl: () => Element | null;
declare const supportsFullscreen: () => boolean;
declare const supportsPictureInPicture: () => boolean;
declare const enterFullscreen: (el: Element) => Promise<void>;
declare const exitFullscreen: (el: Element) => Promise<void>;
declare function addSafeClicks(el: SafeClickEl | null | undefined, onClick?: (e: MouseEvent) => void | null, onDblClick?: (e: MouseEvent) => void | null, options?: boolean | AddEventListenerOptions): void;
declare const removeSafeClicks: (el: SafeClickEl | null | undefined) => void;
declare const intersectionObserver: IntersectionObserver | null;
declare const resizeObserver: ResizeObserver | null;
declare const mutationObserver: MutationObserver | null;
declare function observeResize(el: Element, cb: (entry: ResizeObserverEntry) => void): () => false | void | undefined;
declare function observeIntersection(el: Element, cb: (entry: IntersectionObserverEntry) => void): () => false | void | undefined;
declare function observeMutation(el: Element, cb: (mutations: MutationRecord[]) => void, options: MutationObserverInit): () => void;
declare const rippleHandler: (e: PointerEvent, target?: HTMLElement, forceCenter?: boolean) => void;
export interface ScrolleratorOptions {
	baseSpeed?: number;
	maxSpeed?: number;
	stepDelay?: number;
	baseRate?: number;
	lineHeight?: number;
	margin?: number;
	car?: Window | HTMLElement;
}
export interface Scrollerator {
	drive: (clientY: number, brake?: boolean, offsetY?: number) => number;
	reset: () => void;
}
declare const initVScrollerator: ({ baseSpeed, maxSpeed, stepDelay, baseRate, lineHeight, margin, car }?: ScrolleratorOptions) => Scrollerator;
export interface ScrollAssistControl {
	update: () => void;
	destroy: () => void;
}
export interface ScrollAssistOptions {
	pxPerSecond?: number;
	assistClassName?: string;
	vertical?: boolean;
	horizontal?: boolean;
}
declare const initScrollAssist: (el: HTMLElement, { pxPerSecond, assistClassName, vertical, horizontal }?: ScrollAssistOptions) => ScrollAssistControl | void;
declare const removeScrollAssist: (el: HTMLElement) => void | undefined;
export interface ArrowNavConfig {
	enabled?: boolean | null;
	selector?: string;
	focusOnHover?: boolean;
	loop?: boolean;
	virtual?: boolean;
	typeahead?: boolean;
	resetMs?: number;
	rtl?: boolean | null;
	rovingTabIndex?: boolean | null;
	defaultTabbableIndex?: number | null;
	activeClass?: string;
	inputSelector?: string;
	scrollIntoView?: ScrollIntoViewOptions;
	focusOptions?: FocusOptions;
	grid?: Partial<Record<"x" | "y" | "vY", number>>;
	onSelect?: (el: HTMLElement, e: Partial<KeyboardEvent> & {
		key: string;
	}) => void;
	onFocusOut?: () => void;
}
export type KeyEvent = Partial<KeyboardEvent> & {
	key: string;
};
export type ArrowNavHandle = {
	goToIndex: (index: number, e?: KeyEvent) => void;
	simulateKey: (e: KeyEvent) => void;
	getAbleIndex: (targetIndex: number, e?: KeyEvent) => number | null;
	typeAhead: (key: string) => void;
	items: () => HTMLElement[];
	activeItem: () => HTMLElement | null;
	getGrid: () => {
		x: number;
		y: number;
		vY: number;
	};
	destroy: () => void;
};
declare const initArrowFocusNav: (container: HTMLElement, cfg?: ArrowNavConfig) => ArrowNavHandle;
export interface RuntimeState {
	readyState: number;
	audioContextReady: boolean;
	mediaIntersecting: boolean;
	mediaParentIntersecting: boolean;
	dimensions: {
		container: Dimensions & {
			tier: string;
		};
		pseudoContainer: Dimensions & {
			tier: string;
		};
		window: Dimensions;
	};
	screenOrientation: ScreenOrientation;
	docVisibilityState: DocumentVisibilityState;
	docInFullscreen: boolean;
}
export declare let AUDIO_CONTEXT: AudioContext | null;
export declare let AUDIO_LIMITER: DynamicsCompressorNode | null;
export declare let IS_DOC_TRANSIENT: boolean;
export declare const Controllers: Controller[];
export declare function mountMedia(): void;
export declare function unmountMedia(): void;
export declare function startAudioManager(): void;
export declare function connectMediaToAudioManager(medium: HTMLMediaElement): "unavailable" | undefined;
export declare function getAudioContext(): AudioContext | null;
export declare function init(): void;
export type UIOption<T> = T | {
	value: T;
	display: string;
};
export interface UISettings<T> {
	value: T;
	options: UIOption<T>[];
	[key: string]: any;
}
export interface UIConfig<T> {
	values: T[];
	displays: string[];
}
export type UIObject<T> = {
	[K in keyof T as T[K] extends object ? K : never]: T[K] extends UISettings<infer U> ? UIConfig<U> : UIObject<T[K]>;
};
// === Type definition for T007 Toast Library (Global) ===
export type ToastType = "success" | "error" | "warning" | "info";
export type ToastOptions = Partial<{
	id: string;
	idPrefix: string;
	render: string;
	type: ToastType;
	image: string | boolean;
	icon: string;
	autoClose: boolean | number; //
	position: "top-right" | "top-left" | "top-center" | "bottom-right" | "bottom-left" | "bottom-center" | "cetner-right" | "center-left" | "center-center";
	onClose: (timeElapsed: boolean) => void;
	onTimeUpdate: (time: number) => void;
	closeButton: boolean;
	closeOnClick: boolean;
	isLoading: boolean | string; // icon HTML
	nprogress: number;
	dragToClose: boolean | "mouse" | "touch" | "pen";
	dragToClosePercent: number | {
		x: number;
		y: number;
	};
	dragToCloseDir: "x" | "y" | "xy" | "x|y" | "x||y" | "x+" | "x-" | "y+" | "y-" | "xy+" | "xy-" | "x|y+" | "x|y-" | "x||y+" | "x||y-";
	hideProgressBar: boolean;
	pauseOnHover: boolean;
	pauseOnFocusLoss: boolean;
	renotify: boolean;
	tag: string | number;
	vibrate: boolean | number[];
	delay: number;
	bodyHTML: string;
	animation: "fade" | "zoom" | "slide" | "slide-left" | "slide-right" | "slide-up" | "slide-down";
	actions: Record<string, () => void>;
	rootElement: any; // HTMLElement
	maxToasts: number;
	newestOnTop: boolean;
}>;
declare const errorCodes: readonly [
	1,
	2,
	3,
	4,
	5
];
declare const modes: readonly [
	"fullscreen",
	"theater",
	"pictureInPicture",
	"miniplayer"
];
declare const controls: readonly [
	"expandminiplayer",
	"removeminiplayer",
	"meta",
	"timeline",
	"capture",
	"fullscreenorientation",
	"fullscreenlock",
	"prev",
	"playpause",
	"next",
	"brightness",
	"volume",
	"timeandduration",
	"spacer",
	"playbackrate",
	"captions",
	"settings",
	"objectfit",
	"pictureinpicture",
	"theater",
	"fullscreen"
];
declare const bigControls: readonly [
	"bigprev",
	"bigplaypause",
	"bignext"
];
declare const keyShortcutActions: readonly [
	"prev",
	"next",
	"playPause",
	"skipBwd",
	"skipFwd",
	"stepFwd",
	"stepBwd",
	"mute",
	"dark",
	"volumeUp",
	"volumeDown",
	"brightnessUp",
	"brightnessDown",
	"playbackRateUp",
	"playbackRateDown",
	"timeMode",
	"timeFormat",
	"capture",
	"objectFit",
	"pictureInPicture",
	"theater",
	"fullscreen",
	"captions",
	"captionsFontSizeUp",
	"captionsFontSizeDown",
	"captionsFontFamily",
	"captionsFontWeight",
	"captionsFontVariant",
	"captionsFontOpacity",
	"captionsBackgroundOpacity",
	"captionsWindowOpacity",
	"captionsCharacterEdgeStyle",
	"captionsTextAlignment",
	"settings"
];
declare const moddedKeyShortcutActions: readonly [
	"skip",
	"volume",
	"brightness",
	"playbackRate",
	"captionsFontSize"
];
declare const aptAutoplayOptions: string[];
declare const orientationOptions: readonly [
	"auto",
	"landscape",
	"portrait",
	"portrait-primary",
	"portrait-secondary",
	"landscape-primary",
	"landscape-secondary"
];
export type ErrorCode = (typeof errorCodes)[number];
export type Mode = (typeof modes)[number];
export type KeyShortcutAction = (typeof keyShortcutActions)[number];
export type ModdedKeyShortcutAction = (typeof moddedKeyShortcutActions)[number];
export type AptAutoplayOption = (typeof aptAutoplayOptions)[number];
export type OrientationOption = (typeof orientationOptions)[number];
export interface PosterPreview {
	usePoster: boolean;
	time: number;
	tease: boolean;
}
export interface AptRange {
	min: number;
	max: number;
	step: number;
}
export interface OptRange {
	min: number;
	max: number;
	value: number;
	skip: number;
}
export interface LightState {
	disabled: boolean;
	controls: (Control | BigControl)[] | boolean;
	preview: PosterPreview;
}
// NOTE: Use deep partial util where necessary after imports
export interface Captions {
	disabled: boolean;
	allowVideoOverride: boolean;
	font: {
		family: UISettings<string>;
		size: OptRange & {
			options: UIOption<number>[];
		};
		color: UISettings<string>;
		opacity: UISettings<number>;
		weight: UISettings<string | number>;
		variant: UISettings<string>;
	};
	window: {
		color: UISettings<string>;
		opacity: UISettings<number>;
	};
	background: {
		color: UISettings<string>;
		opacity: UISettings<number>;
	};
	characterEdgeStyle: UISettings<"none" | "raised" | "depressed" | "outline" | "drop-shadow">;
	textAlignment: UISettings<"left" | "center" | "right">;
}
export interface Toasts extends ToastOptions {
	disabled: boolean;
	nextVideoPreview: PosterPreview;
	captureAutoClose: number;
}
export interface Settings {
	noOverride: keyof Settings | boolean;
	auto: {
		play: boolean | AptAutoplayOption;
		pause: boolean | AptAutoplayOption;
		next: number; // -1 for false
	};
	css: Css;
	brightness: OptRange;
	captions: Captions;
	controlPanel: ControlPanel;
	errorMessages: Record<ErrorCode, string>;
	fastPlay: {
		playbackRate: number;
		key: boolean;
		pointer: {
			type: string;
			threshold: number;
			inset: number;
		};
		reset: boolean;
		rewind: boolean;
	};
	gesture: Gesture;
	keys: {
		disabled: boolean;
		strictMatches: boolean;
		overrides: string[];
		blocks: string[];
		shortcuts: Record<KeyShortcutAction, string | string[]>;
		mods: {
			disabled: boolean;
		} & Record<ModdedKeyShortcutAction, Record<"ctrl" | "alt" | "shift", number>>;
	};
	locked: Locked;
	modes: {
		fullscreen: {
			disabled: boolean;
			orientationLock: boolean | OrientationOption;
			onRotate: boolean | number; // 0-portrait, 90-landscape, 180, 270
		};
		theater: boolean;
		pictureInPicture: {
			disabled: boolean;
			floatingPlayer: {
				disabled: boolean;
				width: number;
				height: number;
				disallowReturnToOpener: boolean;
				preferInitialWindowPlacement: boolean;
			};
		};
		miniplayer: {
			disabled: boolean;
			minWindowWidth: number;
		};
	};
	notifiers: boolean;
	overlay: Overlay;
	persist: Persist;
	playbackRate: OptRange;
	playsInline: boolean;
	techOrder: string[];
	time: Time;
	toasts: Toasts;
	volume: Volume;
}
export type VideoBuild = {
	id: string;
	debug: boolean;
	disabled: boolean;
	initialMode: Mode;
	lightState: LightState;
	media: MediaMetadata & {
		id: string;
		title: string;
		artist: string;
		profile: string;
		album: string;
		artwork: Array<{
			src: string;
			sizes: string;
			type: string;
		}>;
		chapterInfo: Array<{
			title: string;
			startTime: number;
			artwork: Array<{
				src: string;
				sizes: string;
				type: string;
			}>;
		}>;
		links: Record<"title" | "artist" | "profile", string>;
	};
	mediaPlayer: "TMG";
	mediaType: "video";
	playlist: Playlist;
	settings: Settings;
	sources: Sources;
	src: Src;
	srcObject: SrcObject;
	tracks: Tracks;
	cloneOnDetach: boolean; // stateful issues, src resets - freezing, etc.
	noPlugList: string[]; // for non-core plugs
};
declare const methods: readonly [
	"tick",
	"stall",
	"nostall",
	"get",
	"gonce",
	"noget",
	"set",
	"sonce",
	"noset",
	"watch",
	"wonce",
	"nowatch",
	"on",
	"once",
	"off",
	"cascade",
	"snapshot",
	"reset",
	"destroy"
];
export type Reactive<T extends object> = T & Pick<Reactor<T>, (typeof methods)[number]>;
export type BaseTechConfig = Reactive<Media>;
export interface TechConstructor<T extends BaseTech = BaseTech> {
	new (ctl: Controller, config: any): T;
	techName: string;
	features: MediaFeatures;
	canPlaySource(src: string): boolean;
}
declare abstract class BaseTech<Config extends BaseTechConfig = BaseTechConfig, El extends HTMLElement = HTMLElement> extends Controllable<Config> {
	static readonly techName: string;
	get name(): string;
	static readonly features: MediaFeatures;
	get features(): MediaFeatures;
	element: HTMLElement;
	protected get el(): El;
	constructor(ctl: Controller, config: Config);
	onSetup(): void;
	onDestroy(): void;
	static canPlaySource(src: string): boolean;
	mount(): void;
	unmount(): void;
	wire(): void;
	protected abstract wireSrc(): void;
	protected abstract wireCurrentTime(): void;
	protected abstract wireDuration(): void;
	protected abstract wirePaused(): void;
	protected abstract wireEnded(): void;
	protected wireFeatures(): void;
	protected wireVolume?(): void;
	protected wireMuted?(): void;
	protected wirePlaybackRate?(): void;
	protected wirePictureInPicture?(): void;
	protected wireFullscreen?(): void;
	protected wireAirplay?(): void;
	protected wireChromecast?(): void;
	protected wireXRSession?(): void;
	protected wireXRMode?(): void;
	protected wireXRReferenceSpace?(): void;
	protected wireProjection?(): void;
	protected wireStereoMode?(): void;
	protected wireFieldOfView?(): void;
	protected wireAspectRatio?(): void;
	protected wirePanningX?(): void;
	protected wirePanningY?(): void;
	protected wirePanningZ?(): void;
	protected wireXRInputSource?(): void;
	protected wireAutoLevel?(): void;
	protected wireCurrentLevel?(): void;
	protected wireCurrentAudioTrack?(): void;
	protected wireCurrentVideoTrack?(): void;
	protected wireCurrentTextTrack?(): void;
	protected wirePoster?(): void;
	protected wireAutoplay?(): void;
	protected wireLoop?(): void;
	protected wirePreload?(): void;
	protected wirePlaysInline?(): void;
	protected wireCrossOrigin?(): void;
	protected wireControls?(): void;
	protected wireControlsList?(): void;
	protected wireDisablePictureInPicture?(): void;
	protected wireSources?(): void;
	protected wireTracks?(): void;
}
export interface LifePayload {
	readyState: number;
	initialized: boolean;
	destroyed: boolean;
	instance: Controller;
}
export declare class Controller {
	readonly id: string;
	plugs: Map<string, BasePlug<any, any>>;
	getPlug<T extends BasePlug = BasePlug>(name: string): T | undefined;
	private ac;
	readonly signal: AbortSignal;
	config: Reactive<VideoBuild>;
	state: Reactive<RuntimeState> & Record<string, any>;
	media: Reactive<Media>;
	buildCache: VideoBuild;
	private payloadCache;
	videoContainer: HTMLElement;
	pseudoVideo: HTMLVideoElement;
	pseudoVideoContainer: HTMLElement;
	DOM: Record<string, HTMLElement | null>;
	private throttleMap;
	private rafLoopMap;
	private rafLoopFnMap;
	mutatingDOMM: boolean;
	constructor(medium: HTMLVideoElement, build: VideoBuild);
	private boot;
	private connectPlugs;
	plugin(PlugClass: PlugConstructor, config?: any): void;
	protected wireTechOverseer(): void;
	protected overseeTech(pref?: "state" | "intent"): void;
	switchTech(TechClass: TechConstructor, config?: Reactive<Media>): void;
	private wireRuntimeState;
	get payload(): LifePayload;
	setReadyState(state?: number, medium?: HTMLVideoElement): void;
	guard: <T extends Function>(fn: T, { silent }?: {
		silent?: boolean | undefined;
	}) => T;
	log(mssg: any, type?: "error" | "warn" | "log", action?: "swallow"): void;
	fire(eN: string, detail?: any, el?: HTMLElement | EventTarget, bubbles?: boolean, cancelable?: boolean): void;
	throttle(key: string, fn: Function, delay?: number, strict?: boolean): any;
	RAFLoop(key: string, fn: Function): void;
	cancelRAFLoop(key: string): void;
	queryDOM<K extends keyof HTMLElementTagNameMap>(query: K, all: true, isPseudo?: boolean): NodeListOf<HTMLElementTagNameMap[K]>;
	queryDOM<K extends keyof SVGElementTagNameMap>(query: K, all: true, isPseudo?: boolean): NodeListOf<SVGElementTagNameMap[K]>;
	queryDOM<E extends Element = HTMLElement>(query: string, all: true, isPseudo?: boolean): NodeListOf<E>;
	queryDOM<K extends keyof HTMLElementTagNameMap>(query: K, all?: false, isPseudo?: boolean): HTMLElementTagNameMap[K] | null;
	queryDOM<K extends keyof SVGElementTagNameMap>(query: K, all?: false, isPseudo?: boolean): SVGElementTagNameMap[K] | null;
	queryDOM<E extends Element = HTMLElement>(query: string, all?: false, isPseudo?: boolean): E | null;
	setImgLoadState<T extends {
		target: HTMLImageElement;
	}>({ target: img }: T): void;
	setImgFallback<T extends {
		target: HTMLImageElement;
	}>({ target: img }: T): void;
	setCanvasFallback(canvas: HTMLCanvasElement, context: CanvasRenderingContext2D, img?: HTMLImageElement): void;
	isUIActive(mode: string, el?: HTMLElement): boolean;
	destroy(): HTMLVideoElement;
}
declare abstract class Controllable<Config = any, State = any> {
	protected readonly ac: AbortController;
	protected readonly signal: AbortSignal;
	protected readonly ctl: Controller;
	protected readonly guard: Controller["guard"];
	config: Config;
	state: State extends object ? Reactive<State> : State;
	constructor(ctl: Controller, config: Config, state?: State);
	setup(): void;
	protected abstract onSetup(): void;
	destroy(): void;
	protected onDestroy(): void;
}
export interface PlugConstructor<T extends BasePlug = BasePlug> {
	new (ctl: Controller, config: any): T;
	plugName: string;
	isCore: boolean;
}
declare abstract class BasePlug<Config = any, State = any> extends Controllable<Config, State> {
	static readonly plugName: string;
	get name(): string;
	static readonly isCore: boolean;
	protected onSetup(): void;
	mount?(): void;
	wire?(): void;
}
export type Src = string;
export interface Source {
	src: string;
	type: string;
	media: string;
}
export type Sources = Source[];
export type SrcObject = MediaSource | null;
export interface Track {
	kind: string;
	label: string;
	srclang: string;
	src: string;
	default: boolean;
	id: string;
}
export type Tracks = Track[];
declare const timeKeys: readonly [
	"min",
	"max",
	"start",
	"end",
	"previews"
];
export type PlaylistItemTimeKey = (typeof timeKeys)[number];
export interface PlaylistItemBuild extends Pick<VideoBuild, "media" | "src" | "sources" | "tracks"> {
	settings: {
		time: Pick<Settings["time"], PlaylistItemTimeKey>;
	};
}
export type Playlist = PlaylistItemBuild[] | null;
export interface Css extends Record<string, string | number> {
	captionsCharacterEdgeStyle: "none" | "raised" | "depressed" | "uniform" | "dropshadow";
	captionsTextAlignment: "start" | "center" | "end";
}
export type Control = (typeof controls)[number];
export type SControl = Control | "spacer";
export type BigControl = (typeof bigControls)[number];
export type ControlPanelBottomTuple = Record<1 | 2 | 3, SControl[]>;
export interface ControlPanel {
	profile: string | boolean;
	title: string | boolean;
	artist: string | boolean;
	top: SControl[] | boolean;
	center: BigControl[] | boolean;
	bottom: boolean | SControl[] | SControl[][] | Partial<ControlPanelBottomTuple>;
	buffer: "eclipse" | "accent" | boolean;
	timeline: {
		thumbIndicator: boolean;
		seek: {
			relative: boolean;
			cancel: {
				delta: number;
				timeout: number;
			};
		};
	};
	progressBar: boolean;
	draggable: ("" | "big" | "wrapper")[] | boolean;
}
export interface Overlay {
	delay: number;
	behavior: "persistent" | "auto" | "strict" | "hidden";
}
export interface StorageAdapterConstructor {
	new (namespace: string): StorageAdapter;
}
declare abstract class StorageAdapter {
	readonly namespace: string;
	constructor(namespace: string);
	abstract get(key: string): any;
	abstract set(key: string, value: any): void;
	abstract remove(key: string): void;
}
export interface Persist {
	disabled: boolean;
	adapter: StorageAdapterConstructor;
	throttle: number;
}
export type PreviewConfig = boolean | {
	address?: string;
	cols?: number;
	rows?: number;
	spf?: number;
	type?: "sprite" | "image" | "canvas" | "none";
};
export type Locked = {
	disabled: boolean;
};
export interface Time extends OptRange {
	mode: "elapsed" | "remaining";
	format: "digital" | "human" | "human-long";
	start: number | null | undefined;
	end: number;
	loop: boolean;
	previews?: Omit<PreviewConfig, "type"> | boolean;
	seekSync: boolean;
}
export interface WheelConfig {
	volume: {
		normal: boolean;
		slider: boolean;
	};
	brightness: {
		normal: boolean;
		slider: boolean;
	};
	timeline: {
		normal: boolean;
		slider: boolean;
	};
	timeout: number;
	xRatio: number;
	yRatio: number;
}
export interface TouchConfig {
	volume: boolean;
	brightness: boolean;
	timeline: boolean;
	threshold: number;
	sliderTimeout: number;
	xRatio: number;
	yRatio: number;
	axesRatio: number;
	inset: number;
}
export type Gesture = {
	click: string;
	dblClick: string;
	wheel: WheelConfig;
	touch: TouchConfig;
};
export interface Volume extends OptRange {
	muted: boolean;
}
export type Dimensions = Record<"width" | "height", number>;
export type SourceLike = Source | (HTMLSourceElement & Record<string, any>);
export type TrackLike = Track | (HTMLTrackElement & Record<string, any>);
declare function getMediaReport(m: HTMLMediaElement): MediaReport;
declare const getRenderedBox: (elem: HTMLElement & {
	videoWidth?: number;
	videoHeight?: number;
}) => Partial<Dimensions & {
	left: number;
	top: number;
}>;
declare function getSizeTier(container: HTMLElement): {
	width: number;
	height: number;
	tier: string;
};
declare const cloneMedia: <M extends HTMLMediaElement>(v: M) => M;
declare function putSourceDetails(source: any, el: HTMLSourceElement | Record<string, any>): void;
declare function addSources(sources: (SourceLike | Iterable<SourceLike>) | undefined, medium: HTMLElement): HTMLSourceElement | HTMLSourceElement[];
declare function getSources(medium: HTMLElement): MediaState["sources"];
declare const removeSources: (medium: HTMLElement) => void;
declare function isSameSources(a?: Sources, b?: Sources): boolean;
export type TrackType = "Audio" | "Video" | "Text";
declare function putTrackDetails(track: any, el: HTMLTrackElement | Record<string, any>): void;
declare function addTracks(tracks: (TrackLike | Iterable<TrackLike>) | undefined, medium: HTMLElement): HTMLTrackElement | HTMLTrackElement[];
declare function getTracks(medium: HTMLElement, cues?: boolean): TrackLike[];
declare const removeTracks: (medium: HTMLElement) => void;
declare function isSameTracks(a?: Tracks, b?: Tracks): boolean;
declare function getTrackIdx(medium: HTMLMediaElement, type: TrackType, term?: any): number;
declare function setCurrentTrack(medium: HTMLMediaElement, type: TrackType, term: any, flush?: boolean): void;
declare const stripTags: (text: string) => string;
declare function srtToVtt(srt: string, vttLines?: string[]): string;
declare function parseVttText(text: string): string;
declare function formatVttLine(p: string, maxChars: number): string[];
declare function formatMediaTime({ time, format, elapsed, showMs, casing }?: {
	time?: number;
	format?: string;
	elapsed?: boolean;
	showMs?: boolean;
	casing?: "normal" | "upper" | "title";
}): string;
export interface TimeRange {
	length: number;
	start(index: number): number;
	end(index: number): number;
}
declare const createTimeRanges: (ranges?: [
	number,
	number
][] | TimeRange) => TimeRange;
declare function isDef(val: any): boolean;
declare function isArr<T = unknown>(obj: any): obj is T[];
declare function isObj<T extends object = object>(obj: any): obj is T;
declare function isIter<T = unknown>(obj: any): obj is Iterable<T>;
declare function isUISetting<T = unknown>(obj: any): obj is UISettings<T>;
declare function inBoolArrOpt(opt: any, str: string): boolean;
declare function assignDef<T extends object>(target: T, key: Paths<T>, value: PathValue<T, typeof key>): void;
declare function assignHTMLConfig<T extends object>(target: T, attr: `tmg--${Paths<T, "--">}`, value: string): void;
declare function setAny<T extends object, const S extends string = ".">(target: T, key: Paths<T, S>, value: PathValue<T, typeof key, S>, separator?: S, keyFunc?: (p: string) => string): void;
declare function getAny<T extends object, const S extends string = ".">(source: T, key: Paths<T, S>, separator?: S, keyFunc?: (p: string) => string): PathValue<T, typeof key, S> | undefined;
declare function deleteAny<T extends object, const S extends string = ".">(target: T, key: Paths<T, S>, separator?: S, keyFunc?: (p: string) => string): void;
declare function parseUIObj<T extends Record<string, any>>(obj: T): UIObject<T>;
declare function parseAnyObj<T extends Record<string, any>, const S extends string = ".">(obj: T, separator?: S, keyFunc?: (p: string) => string, visited?: WeakSet<WeakKey>): Unflatten<T, S>;
declare function parsePanelBottomObj(obj: Partial<ControlPanelBottomTuple> | Control[][] | Control[] | unknown, arr?: false): ControlPanelBottomTuple | false;
declare function parsePanelBottomObj(obj: Partial<ControlPanelBottomTuple> | Control[][] | Control[] | unknown, arr: true): Control[] | false;
declare function parseEvOpts<T extends object>(options: T | boolean | undefined, opts: (keyof T)[] | readonly (keyof T)[], boolOpt?: keyof T, result?: T): T;
declare function mergeObjs<T1 extends object, T2 extends object>(o1: T1, o2: T2): DeepMerge<T1, T2>;
declare function mergeObjs<T1 extends object>(o1: T1): T1;
declare function mergeObjs<T2 extends object>(o1: undefined | null, o2: T2): T2;
declare function getTrailPaths<T>(path: WCPaths<T>, reverse?: boolean): WCPaths<T>[];
declare function getTrailRecords<T extends object>(obj: T, path: WCPaths<T>): [
	WCPaths<T>,
	PathValue<T, WCPaths<T>>,
	PathValue<T, WCPaths<T>>
][];
declare function deepClone<T>(obj: T, visited?: WeakMap<WeakKey, any>): T;
declare function isValidNum(val: any): boolean;
declare function clamp(min: number | undefined, val: number, max?: number): number;
declare function safeNum(number: any, fallback?: number): number;
declare function parseIfPercent(percent: any, amount?: number): number;
declare function parseCSSTime(time: any): number;
declare function parseCSSUnit(val: any): number;
declare function remToPx(val: number): number;
declare function stepNum<T extends AptRange>(v: number | undefined, { min, max, step }: T): number;
declare function rotate<T>(cur: T, steps: T[], dir?: "forwards" | "backwards", wrap?: boolean): T;
declare function rotate(cur: number, steps: AptRange, dir?: "forwards" | "backwards", wrap?: boolean): number;
declare function capitalize(word?: string): string;
declare function camelize(str?: string, { source }?: RegExp, { preserveInnerCase: pIC, upperFirst: uF }?: {
	preserveInnerCase?: boolean | undefined;
	upperFirst?: boolean | undefined;
}): string;
declare function uncamelize(str?: string, separator?: string): string;
declare function uid(prefix?: string): string;
declare function luid(prefix?: string): string;
declare function isSameURL(src1: unknown, src2: unknown): boolean;
declare function formatSize(size: number, decimals?: number, base?: number): string;
declare function getExtension(fn: string): string;
declare function noExtension(fn: string): string;
declare function getMimeTypeFromExtension(fn: string): string;
export type RGB = [
	number,
	number,
	number
];
export type DominantColorFormat = "rgb" | "hex";
declare function getRGBBri([r, g, b]: RGB): number;
declare function getRGBSat([r, g, b]: RGB): number;
declare function clampRGBBri([r, g, b]: RGB, m?: number): RGB;
declare function getDominantColor(src: string | HTMLImageElement | HTMLCanvasElement | {
	canvas: HTMLCanvasElement;
	width: number;
	height: number;
}, format?: DominantColorFormat, raw?: boolean): Promise<string | RGB | null>;
declare function convertToMonoChrome(canvas: HTMLCanvasElement, context: CanvasRenderingContext2D): void;
declare let IS_ANDROID: boolean;
declare let IS_WINDOWS: boolean;
declare let IS_FIREFOX: boolean;
declare let IS_EDGE: boolean;
declare let IS_CHROME: boolean;
declare let IS_CHROMIUM: boolean;
declare let IS_SAFARI: boolean;
declare let IS_IE: boolean;
declare let IS_TIZEN: boolean;
declare let IS_WEBOS: boolean;
declare let IS_IPOD: boolean;
declare let IS_IPAD: boolean;
declare let IS_IPHONE: boolean;
export type Version = string | null;
declare let IOS_VERSION: Version;
declare let ANDROID_VERSION: Version;
declare let CHROME_VERSION: Version;
declare let CHROMIUM_VERSION: Version;
declare let IE_VERSION: Version;
declare const IS_CHROMECAST_RECEIVER: boolean;
declare const TOUCH_ENABLED: boolean;
declare const IS_IOS: boolean;
declare const IS_MOBILE: boolean;
declare const IS_SMART_TV: boolean;
declare const queryMediaMobile: (query?: string) => boolean;
export type KeyStruct = Record<"ctrlKey" | "shiftKey" | "altKey" | "metaKey", boolean> & {
	key: string;
};
declare function parseKeyCombo(combo: string): KeyStruct;
declare function stringifyKeyCombo(e: KeyStruct | KeyboardEvent): string;
declare function cleanKeyCombo(combo: string | string[]): string | string[];
declare function matchKeys(required: string | string[], actual: string, strict?: boolean): boolean;
declare function getTermsForKey(combo: string, settings: any): {
	override: boolean;
	block: boolean;
	allowed: boolean;
	action: string | null;
};
declare function keyEventAllowed(e: KeyboardEvent, settings: any): boolean | string;
declare const formatKeyForDisplay: (combo: string | string[]) => string;
declare function formatKeyShortcutsForDisplay(keyShortcuts: Record<string, string | string[]>): Record<string, string>;
declare function parseForARIAKS(s: string): string;
declare function setTimeout$1(handler: TimerHandler, timeout?: number, ...args: any[]): number;
declare function setInterval$1(handler: TimerHandler, timeout?: number, ...args: any[]): number;
declare function requestAnimationFrame$1(callback: FrameRequestCallback, sig?: AbortSignal): number;
declare const mockAsync: (timeout?: number) => Promise<void>;
export interface LimitedOptions {
	key?: string; /** Key for localStorage persistence (if omitted, uses session-only) */
	maxTimes?: number; /** Max times to call (default: 1) */
}
export interface LimitedHandle<T extends (...args: any[]) => any> {
	(...args: Parameters<T>): ReturnType<T> | void;
	count: number;
	left: number;
	reset: () => void;
	block: () => void;
}
declare function limited<T extends (...args: any[]) => any>(fn: T, opts?: LimitedOptions | string): LimitedHandle<T>;
declare const oncePerSession: <T extends (...args: any[]) => any>(fn: T) => LimitedHandle<T>;
declare const onceEver: <T extends (...args: any[]) => any>(fn: T, key?: string) => LimitedHandle<T>;
declare function deprecate(message: string): void;
declare function deprecateForMajor(major: number, oldName: string, newName?: string): void;
export type Inert<T> = T & {
	[INERTIA]?: true;
};
export type Intent<T> = T & {
	[REJECTABLE]?: true;
};
export interface ReactorOptions {
}
export interface Target<T, P extends WCPaths<T> = WCPaths<T>> {
	path: P;
	value?: PathValue<T, P>;
	oldValue?: PathValue<T, P>;
	key: string;
	object: PathParentValue<T, P>;
}
export interface Payload<T, P extends WCPaths<T> = WCPaths<T>> {
	type: "init" | "get" | "set" | "delete" | "update"; // init during `immediate: true` sync
	target: Target<T, P>;
	currentTarget: Target<T, P>; // use this always to survive shape changes from nesting
	root: T;
	rejectable: boolean;
}
export type Getter<T, P extends Paths<T> = Paths<T>> = (value: PathValue<T, P> | undefined, payload: Payload<T, P>) => PathValue<T, P> | undefined;
export type Setter<T, P extends Paths<T> = Paths<T>> = (value: PathValue<T, P> | undefined, terminated: boolean, payload: Payload<T, P>) => PathValue<T, P> | typeof TERMINATOR | undefined;
export type Watcher<T, P extends Paths<T> = Paths<T>> = (value: PathValue<T, P> | undefined, payload: Payload<T, P>) => void;
export type Listener<T, P extends WCPaths<T> = WCPaths<T>> = (event: Event$1<T, P>) => void;
export type SyncOptionsTuple = {
	lazy?: boolean;
	once?: boolean;
	signal?: AbortSignal;
	immediate?: boolean;
};
export type SyncOptions = boolean | SyncOptionsTuple;
export type ListenerOptionsTuple = {
	capture?: boolean;
	once?: boolean;
	signal?: AbortSignal;
	immediate?: boolean;
};
export type ListenerOptions = boolean | ListenerOptionsTuple;
export interface MediaContract {
	// "Must Haves" to be even considered media
	src: Src;
	currentTime: number;
	duration: number;
	paused: boolean;
	ended: boolean;
}
export interface MediaState {
	// --- The Big Three (Promise-based State) ---
	src: MediaContract["src"]; // Rejects if network fails or format unsupported
	currentTime: MediaContract["currentTime"]; // Rejects if outside seekable range
	paused: MediaContract["paused"]; // Rejects if "Autoplay Policy" denies it
	// --- The Engine Inputs (Interceptable) ---
	volume: number;
	muted: boolean;
	playbackRate: number;
	// --- The Presentation Modes (Heavily Rejectable) ---
	pictureInPicture: boolean;
	fullscreen: boolean;
	// --- Casting (Connection Handshakes) ---
	airplay: boolean; // Apple AirPlay
	chromecast: boolean; // Google Cast
	// --- VR / XR (Spatial Realities) ---
	xrSession: boolean; // Request "Immersive Mode" (Handshake)
	xrMode: "inline" | "immersive-vr" | "immersive-ar"; // Hardware target
	xrReferenceSpace: "local" | "local-floor" | "bounded-floor" | "unbounded";
	// --- Projection & Stereo (The "Content" Logic) ---
	projection: "flat" | "equirectangular" | "cubemap" | "cylindrical";
	stereoMode: "mono" | "sbs" | "top-bottom" | "vr180" | "none"; // Side-by-Side vs Top-Bottom
	// --- Camera & Viewport (The "Lens") ---
	fieldOfView: number; // Degrees (Vertical FOV)
	aspectRatio: number; // Viewport ratio
	// --- Orientation (The "Head/Camera" Pose) ---
	panningX: number; // Yaw (Left/Right)
	panningY: number; // Pitch (Up/Down)
	panningZ: number; // Roll (Tilt/Barrel)
	// --- Interaction (XR Controllers) ---
	xrInputSource: any; // Reference to active controllers/hand-tracking
	// --- Track Switching (Async Buffering/Streaming) ---
	// NOTE: "Disabled" value is "-1"
	currentTextTrack: number; // Subtitle
	currentAudioTrack: number; // Language (English -> Spanish)
	currentVideoTrack: number; // Angle
	autoLevel: boolean; // ABR Algorithm enabled?
	currentLevel: number; // Quality (1080p -> 4K)
	// --- HTML Attributes ---
	poster: string;
	autoplay: boolean;
	loop: boolean;
	preload: "" | "auto" | "metadata" | "none";
	playsInline: boolean;
	crossOrigin: string | null;
	controls: boolean; // Native controls enabled?
	controlsList: string;
	disablePictureInPicture: boolean;
	// ---  HTML Lists ---
	sources: Sources; // HTML courtesy
	tracks: Tracks; // HTML courtesy
}
export interface MediaIntent extends MediaState {
	currentLevel: any;
	currentAudioTrack: any;
	currentVideoTrack: any;
	currentTextTrack: any;
} // Tech's responsibility to receive `any` intent and produce a `number` that can index their status (track/level) lists
export interface MediaStatus {
	// --- Network & Health ---
	readyState: number;
	networkState: number;
	error: MediaError | null;
	bandwidth: number | null; // Estimated Mbps
	// --- Buffering & Time ---
	waiting: boolean; // Spinner Active?
	stalled: boolean; // Network died?
	seeking: boolean; // Scrubbing?
	buffered: TimeRanges;
	played: TimeRanges;
	seekable: TimeRanges;
	duration: MediaContract["duration"]; // In seconds
	ended: MediaContract["ended"]; // Playback complete?
	// --- Dimensions ---
	videoWidth: number;
	videoHeight: number;
	// --- Lifecycle Gates ---
	loadedMetadata: boolean; // Do we know duration?
	loadedData: boolean; // Can we render frame 1?
	canPlay: boolean; // Can we start?
	canPlayThrough: boolean; // Can we finish?
	// --- Lists ---
	textTracks: TextTrackList | any[];
	audioTracks: any[]; // | AudioTrackList
	videoTracks: any[]; // | VideoTrackList
	levels: any[];
	// --- VR / XR Info ---
	xrCapabilities: Record<"hasPosition" | "hasOrientation" | "isEmulated", // 6DoF- Room-scale, 3DoF- Head rotation, Emulated- Magic Window
	boolean> | null;
	// --- Active Content ---
	activeCue: TextTrackCue | null; // The current subtitle/caption line
}
export interface MediaSettings {
	// --- Defaults (Startup values) ---
	defaultMuted: boolean;
	defaultPlaybackRate: number;
	// --- Stream Sources ---
	srcObject: SrcObject; // HTML courtesy
}
export type MediaFeatures = {
	[K in Exclude<keyof MediaState, keyof MediaContract>]?: boolean;
} & {
	[K in Exclude<keyof MediaStatus, keyof MediaContract>]?: boolean;
} & {
	[K in Exclude<keyof MediaSettings, keyof MediaContract>]?: boolean;
};
export interface MediaReport {
	state: MediaState;
	intent: Intent<MediaIntent>;
	status: MediaStatus;
	settings: MediaSettings;
}
export type Media = {
	tech: Inert<BaseTech>;
	element: HTMLVideoElement;
} & MediaReport;
export type BuildPaths = Paths<VideoBuild>;
export type BuildParam = DeepPartial<VideoBuild> & Record<BuildPaths, PathValue<VideoBuild, BuildPaths>>;
export declare class Player {
	#private;
	constructor(customBuild?: BuildParam);
	get Controller(): Controller | null;
	get build(): VideoBuild;
	set build(customBuild: BuildParam);
	private queryBuild;
	private notice;
	configure(customBuild: BuildParam): void;
	attach(medium: HTMLMediaElement): Promise<void | HTMLMediaElement>;
	detach(): HTMLVideoElement | null | undefined;
	fetchCustomOptions(): Promise<void>;
	private deployController;
}

declare namespace utils {
	export { ANDROID_VERSION, ArrowNavConfig, ArrowNavHandle, CHROME_VERSION, CHROMIUM_VERSION, Dataset, Dimensions, IE_VERSION, IOS_VERSION, IS_ANDROID, IS_CHROME, IS_CHROMECAST_RECEIVER, IS_CHROMIUM, IS_EDGE, IS_FIREFOX, IS_IE, IS_IOS, IS_IPAD, IS_IPHONE, IS_IPOD, IS_MOBILE, IS_SAFARI, IS_SMART_TV, IS_TIZEN, IS_WEBOS, IS_WINDOWS, Style, TOUCH_ENABLED, TimeRange, TrackType, addSafeClicks, addSources, addTracks, assignDef, assignEl, assignHTMLConfig, camelize, capitalize, clamp, clampRGBBri, cleanKeyCombo, cloneMedia, convertToMonoChrome, createEl, createTimeRanges, deepClone, deleteAny, deprecate, deprecateForMajor, enterFullscreen, exitFullscreen, formatKeyForDisplay, formatKeyShortcutsForDisplay, formatMediaTime, formatSize, formatVttLine, getAny, getDominantColor, getElSiblingAt, getExtension, getMediaReport, getMimeTypeFromExtension, getRGBBri, getRGBSat, getRenderedBox, getSizeTier, getSources, getTermsForKey, getTrackIdx, getTracks, getTrailPaths, getTrailRecords, inBoolArrOpt, inDocView, initArrowFocusNav, initScrollAssist, initVScrollerator, intersectionObserver, isArr, isDef, isIter, isObj, isSameSources, isSameTracks, isSameURL, isUISetting, isValidNum, keyEventAllowed, limited, loadResource, luid, matchKeys, mergeObjs, mockAsync, mutationObserver, noExtension, observeIntersection, observeMutation, observeResize, onceEver, oncePerSession, parseAnyObj, parseCSSTime, parseCSSUnit, parseEvOpts, parseForARIAKS, parseIfPercent, parseKeyCombo, parsePanelBottomObj, parseUIObj, parseVttText, putSourceDetails, putTrackDetails, queryFullscreen, queryFullscreenEl, queryMediaMobile, remToPx, removeSafeClicks, removeScrollAssist, removeSources, removeTracks, requestAnimationFrame$1 as requestAnimationFrame, resizeObserver, rippleHandler, rotate, safeNum, setAny, setCurrentTrack, setInterval$1 as setInterval, setTimeout$1 as setTimeout, srtToVtt, stepNum, stringifyKeyCombo, stripTags, supportsFullscreen, supportsPictureInPicture, uid, uncamelize };
}

export {
	utils,
};

export {};
