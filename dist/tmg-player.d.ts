// Generated by dts-bundle-generator v9.5.1

export type Dataset = Record<string, string | number>;
export type Style = Partial<CSSStyleDeclaration>;
export type Direction = "x" | "y";
export type Position = "before" | "after" | "at";
export type ResourceType = "style" | "script" | string;
export type SafeClickEl = HTMLElement & {
	_clickHandler?: (e: MouseEvent) => void;
	_dblClickHandler?: (e: MouseEvent) => void;
	_clickTimeoutId?: ReturnType<typeof setTimeout>;
};
export type LoadResourceOptions = Partial<{
	module: boolean;
	media: string;
	crossOrigin: "anonymous" | "use-credentials" | string | null;
	integrity: string;
	referrerPolicy: "no-referrer" | "origin" | "strict-origin-when-cross-origin" | string;
	nonce: string;
	fetchPriority: "high" | "low" | "auto";
	attempts: number;
	retryKey: boolean | string;
}>;
declare function createEl<K extends keyof HTMLElementTagNameMap>(tag: K, props?: Partial<HTMLElementTagNameMap[K]>, dataset?: Dataset, styles?: Style): HTMLElementTagNameMap[K];
declare function createEl(tag: string, props?: Partial<HTMLElement>, dataset?: Dataset, styles?: Style): HTMLElement | null;
declare function assignEl<K extends keyof HTMLElementTagNameMap>(el?: HTMLElementTagNameMap[K], props?: Partial<HTMLElementTagNameMap[K]>, dataset?: Dataset, styles?: Style): void;
declare function assignEl(el?: HTMLElement, props?: Partial<HTMLElement>, dataset?: Dataset, styles?: Style): void;
declare function loadResource(src: string, type?: ResourceType, { module, media, crossOrigin, integrity, referrerPolicy, nonce, fetchPriority, attempts, retryKey }?: LoadResourceOptions): Promise<HTMLElement | void>;
declare function inDocView(el: Element, axis?: "x" | "y"): boolean;
declare function getElSiblingAt(p: number, dir: Direction, els: HTMLElement[] | NodeListOf<HTMLElement>, pos?: Position): Element | undefined;
declare const queryFullscreen: () => boolean;
declare function queryFullscreenEl(): Element | null;
declare function supportsFullscreen(): boolean;
declare function supportsPictureInPicture(): boolean;
declare function enterFullscreen(el: Element): Promise<void>;
declare function exitFullscreen(el: Element): Promise<void>;
declare function addSafeClicks(el: SafeClickEl | null | undefined, onClick?: (e: MouseEvent) => void | null, onDblClick?: (e: MouseEvent) => void | null, options?: boolean | AddEventListenerOptions): void;
declare function removeSafeClicks(el: SafeClickEl | null | undefined): void;
declare const intersectionObserver: IntersectionObserver | null;
declare const resizeObserver: ResizeObserver | null;
declare const mutationObserver: MutationObserver | null;
declare function observeResize(el: Element, cb: (entry: ResizeObserverEntry) => void): () => false | void | undefined;
declare function observeIntersection(el: Element, cb: (entry: IntersectionObserverEntry) => void): () => false | void | undefined;
declare function observeMutation(el: Element, cb: (mutations: MutationRecord[]) => void, options: MutationObserverInit): () => void;
declare function rippleHandler(e: PointerEvent, target?: HTMLElement, forceCenter?: boolean): void;
export interface ScrolleratorOptions {
	baseSpeed?: number;
	maxSpeed?: number;
	stepDelay?: number;
	baseRate?: number;
	lineHeight?: number;
	margin?: number;
	car?: Window | HTMLElement;
}
export interface Scrollerator {
	drive: (clientY: number, brake?: boolean, offsetY?: number) => number;
	reset: () => void;
}
declare function initVScrollerator({ baseSpeed, maxSpeed, stepDelay, baseRate, lineHeight, margin, car }?: ScrolleratorOptions): Scrollerator;
export interface ScrollAssistControl {
	update: () => void;
	destroy: () => void;
}
export interface ScrollAssistOptions {
	pxPerSecond?: number;
	assistClassName?: string;
	vertical?: boolean;
	horizontal?: boolean;
}
declare function initScrollAssist(el: HTMLElement, { pxPerSecond, assistClassName, vertical, horizontal }?: ScrollAssistOptions): ScrollAssistControl | void;
declare const removeScrollAssist: (el: HTMLElement) => void | undefined;
export interface ArrowNavConfig {
	enabled?: boolean | null;
	selector?: string;
	focusOnHover?: boolean;
	loop?: boolean;
	virtual?: boolean;
	typeahead?: boolean;
	resetMs?: number;
	rtl?: boolean | null;
	rovingTabIndex?: boolean | null;
	defaultTabbableIndex?: number | null;
	activeClass?: string;
	inputSelector?: string;
	scrollIntoView?: ScrollIntoViewOptions;
	focusOptions?: FocusOptions;
	grid?: Partial<Record<"x" | "y" | "vY", number>>;
	onSelect?: (el: HTMLElement, e: Partial<KeyboardEvent> & {
		key: string;
	}) => void;
	onFocusOut?: () => void;
}
export type KeyEvent = Partial<KeyboardEvent> & {
	key: string;
};
export type ArrowNavHandle = {
	goToIndex: (index: number, e?: KeyEvent) => void;
	simulateKey: (e: KeyEvent) => void;
	getAbleIndex: (targetIndex: number, e?: KeyEvent) => number | null;
	typeAhead: (key: string) => void;
	items: () => HTMLElement[];
	activeItem: () => HTMLElement | null;
	getGrid: () => {
		x: number;
		y: number;
		vY: number;
	};
	destroy: () => void;
};
declare function initArrowFocusNav(container: HTMLElement, cfg?: ArrowNavConfig): ArrowNavHandle;
export type Primitive = string | number | boolean | bigint | symbol | null | undefined;
export type NoTraverse = Primitive | Function | Date | Error | RegExp | Promise<any> | Map<any, any> | WeakMap<any, any> | Set<any> | WeakSet<any> | HTMLElement | Element | Node | EventTarget | Window | Document | AbortSignal | Inert<unknown>;
export type WCPaths<T> = "*" | Paths<T>;
export type Paths<T, S extends string = "."> = T extends NoTraverse ? never : T extends readonly (infer U)[] ? `${Extract<keyof T, number>}` | `${Extract<keyof T, number>}${S}${Paths<U, S>}` : {
	[K in keyof T & (string | number)]: T[K] extends Primitive ? `${K}` : `${K}` | `${K}${S}${Paths<T[K], S>}`;
}[keyof T & (string | number)];
export type PathValue<T, P extends string = Paths<T>, S extends string = "."> = P extends "*" ? T : P extends `${infer K}${S}${infer Rest}` ? K extends keyof T ? PathValue<T[K], Rest, S> : never : P extends keyof T ? T[P] : never;
export type PathParentValue<T, P extends string = Paths<T>> = P extends `${infer Parent}.${infer _Rest}` ? Parent extends "" ? T : PathValue<T, Parent> : T;
// Turns dotted keys into nested objects while preserving value types
export type Unflatten<T extends Record<string, any>, S extends string = "."> = UnionToIntersection<{
	[K in keyof T & string]: UnflattenKey<K, T[K], S>;
}[keyof T & string]>;
export type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;
export type UnflattenKey<K extends string, V, S extends string> = K extends `${infer Head}${S}${infer Tail}` ? {
	[P in Head]: UnflattenKey<Tail, V, S>;
} : {
	[P in K]: V;
};
// "It's not that deep" Warriors
export type DeepMerge<T1, T2> = T2 extends object ? T1 extends object ? {
	[K in keyof T1 | keyof T2]: K extends keyof T2 ? K extends keyof T1 ? DeepMerge<T1[K], T2[K]> : T2[K] : K extends keyof T1 ? T1[K] : never;
} : T2 : T2;
export type DeepPartial<T> = T extends Function ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends object ? {
	[P in keyof T]?: DeepPartial<T[P]>;
} : T;
export declare const RAW: unique symbol;
export declare const REJECTABLE: unique symbol;
export declare const INERTIA: unique symbol;
export declare const TERMINATOR: unique symbol;
export declare const REOPTS: {
	readonly LISTENER: readonly [
		"capture",
		"depth",
		"once",
		"signal",
		"immediate"
	];
	readonly MEDIATOR: readonly [
		"lazy",
		"signal",
		"immediate"
	];
};
declare class Event$1<T, P extends WCPaths<T> = WCPaths<T>> {
	static readonly NONE = 0;
	static readonly CAPTURING_PHASE = 1;
	static readonly AT_TARGET = 2;
	static readonly BUBBLING_PHASE = 3;
	type: Payload<T, P>["type"];
	currentTarget: Payload<T, P>["currentTarget"];
	eventPhase: number;
	readonly staticType: Payload<T, P>["type"];
	readonly target: Payload<T, P>["target"];
	readonly root: Payload<T, P>["root"];
	readonly path: Target<T, P>["path"];
	readonly value: Target<T, P>["value"];
	readonly oldValue: Target<T, P>["oldValue"];
	readonly rejectable: boolean;
	readonly bubbles: boolean;
	private _propagationStopped;
	private _immediatePropagationStopped;
	private _resolved;
	private _rejected;
	constructor(payload: Payload<T, P>, bubbles?: boolean);
	get propagationStopped(): boolean;
	stopPropagation(): void;
	get immediatePropagationStopped(): boolean;
	stopImmediatePropagation(): void;
	get resolved(): string;
	resolve(message?: string): void;
	get rejected(): string;
	reject(reason?: string): void;
	composedPath(): WCPaths<T>[];
}
declare class Reactor<T extends object> {
	private getters;
	private setters;
	private watchers;
	private listenersRecord;
	private batch;
	private isBatching;
	private queue;
	private proxyCache;
	private lineage;
	core: T;
	constructor(obj?: T, options?: ReactorOptions);
	private proxify;
	private trace;
	private link;
	private unlink;
	private mediate;
	private notify;
	private schedule;
	private initBatching;
	private flush;
	private wave;
	private fire;
	private bind;
	private getContext;
	getDepth(p: string, d?: number): number;
	tick(paths?: Paths<T> | Iterable<Paths<T>>): void;
	stall(task: () => any): void;
	nostall(task: () => any): boolean | undefined;
	get<P extends Paths<T>>(path: P, cb: Getter<T, P>, opts?: SyncOptions): Reactor<T>["noget"];
	gonce<P extends Paths<T>>(path: P, cb: Getter<T, P>, opts?: SyncOptions): Reactor<T>["noget"];
	noget<P extends Paths<T>>(path: P, cb: Getter<T, P>): boolean | undefined;
	set<P extends Paths<T>>(path: P, cb: Setter<T, P>, opts?: SyncOptions): Reactor<T>["noset"];
	sonce<P extends Paths<T>>(path: P, cb: Setter<T, P>, opts?: SyncOptions): Reactor<T>["noset"];
	noset<P extends Paths<T>>(path: P, cb: Setter<T, P>): boolean | undefined;
	watch<P extends Paths<T>>(path: P, cb: Watcher<T, P>, opts?: SyncOptions): Reactor<T>["nowatch"];
	wonce<P extends Paths<T>>(path: P, cb: Watcher<T, P>, opts?: SyncOptions): Reactor<T>["nowatch"];
	nowatch<P extends Paths<T>>(path: P, cb: Watcher<T, P>): boolean | undefined;
	on<P extends WCPaths<T>>(path: P, cb: Listener<T, P>, options?: ListenerOptions): Reactor<T>["off"];
	once<P extends WCPaths<T>>(path: P, cb: Listener<T, P>, options?: ListenerOptions): Reactor<T>["off"];
	off<P extends WCPaths<T>>(path: P, cb: Listener<T, P>, options?: ListenerOptions): boolean | undefined;
	cascade({ type, currentTarget: { path, value: news, oldValue: olds } }: Event$1<T>, objSafe?: boolean): void;
	snapshot(): T;
	reset(): void;
	destroy(): void;
}
export type Inert<T> = T & {
	[INERTIA]?: true;
};
export type Live<T> = T extends Inert<infer U> ? U : T;
export type Intent<T> = T & {
	[REJECTABLE]?: true;
};
export type State<T> = T extends Intent<infer U> ? U : T;
export interface ReactorOptions {
}
export interface Target<T, P extends WCPaths<T> = WCPaths<T>> {
	path: P;
	value?: PathValue<T, P>;
	oldValue?: PathValue<T, P>;
	key: string;
	object: PathParentValue<T, P>;
}
export interface Payload<T, P extends WCPaths<T> = WCPaths<T>> {
	type: "init" | "get" | "set" | "delete" | "update"; // init during `immediate: true` sync
	target: Target<T, P>;
	currentTarget: Target<T, P>; // use this always to survive shape changes from nesting
	root: T;
	rejectable: boolean;
}
export type Getter<T, P extends Paths<T> = Paths<T>> = (value: PathValue<T, P> | undefined, payload: Payload<T, P>) => PathValue<T, P> | undefined;
export type Setter<T, P extends Paths<T> = Paths<T>> = (value: PathValue<T, P> | undefined, terminated: boolean, payload: Payload<T, P>) => PathValue<T, P> | typeof TERMINATOR | undefined;
export type Watcher<T, P extends Paths<T> = Paths<T>> = (value: PathValue<T, P> | undefined, payload: Payload<T, P>) => void;
export type Listener<T, P extends WCPaths<T> = WCPaths<T>> = (event: Event$1<T, P>) => void;
export interface SyncOptionsTuple {
	lazy?: boolean;
	once?: boolean;
	signal?: AbortSignal;
	immediate?: boolean | "auto";
}
export type SyncOptions = boolean | SyncOptionsTuple;
export interface ListenerOptionsTuple extends Omit<SyncOptionsTuple, "lazy"> {
	capture?: boolean;
	depth?: number;
}
export type ListenerOptions = boolean | ListenerOptionsTuple;
declare function onAllMethods(owner: any, callback: (method: string, owner: any) => void): void;
declare function bindAllMethods(owner: any): void;
declare function guardAllMethods(owner: any, guardFn?: (fn: Function) => Function, bound?: boolean): void;
declare function guardMethod<T extends Function>(fn: T, onError?: (e: any) => void): T;
declare const methods: readonly [
	"tick",
	"stall",
	"nostall",
	"get",
	"gonce",
	"noget",
	"set",
	"sonce",
	"noset",
	"watch",
	"wonce",
	"nowatch",
	"on",
	"once",
	"off",
	"cascade",
	"snapshot",
	"reset",
	"destroy"
];
export type Reactive<T extends object> = T & Pick<Reactor<T>, (typeof methods)[number]>;
declare function reactive<T extends object>(target: T | Reactor<T>, options?: ReactorOptions): Reactive<T>;
declare function inert<T extends object>(target: T): Inert<T>;
declare function live<T extends object>(target: T): Live<T>;
declare function isInert<T extends object>(target: T): target is Inert<T>;
declare function intent<T extends object>(target: T): Intent<T>;
declare function state<T extends object>(target: T): State<T>;
declare function isIntent<T extends object>(target: T): target is Intent<T>;
declare function nuke(target: any): void;
export declare abstract class Controllable<Config = any, State = any> {
	protected readonly ac: AbortController;
	protected readonly signal: AbortSignal;
	protected readonly ctlr: Controller;
	protected readonly guard: Controller["guard"];
	config: Config;
	state: State extends object ? Reactive<State> : State;
	constructor(ctlr: Controller, config: Config, state?: State);
	setup(): void;
	protected abstract onSetup(): void;
	destroy(): void;
	protected onDestroy(): void;
}
export interface PlugConstructor<T extends BasePlug = BasePlug> {
	new (ctlr: Controller, config: any): T;
	plugName: string;
	isCore: boolean;
}
declare abstract class BasePlug<Config = any, State = any> extends Controllable<Config, State> {
	static readonly plugName: string;
	get name(): string;
	static readonly isCore: boolean;
	protected onSetup(): void;
	mount?(): void;
	wire?(): void;
}
declare abstract class BaseModule<Config = any, State = any> extends Controllable<Config, State> {
	static readonly moduleName: string;
	get name(): string;
	protected onSetup(): void;
	mount?(): void;
	wire?(): void;
}
export type Skeleton = undefined;
declare class SkeletonPlug extends BasePlug<Skeleton> {
	static readonly plugName: string;
	static readonly isCore: boolean;
	mount(): void;
	wire(): void;
	protected setupContainers(): void;
	protected injectInterface(): void;
	protected handlePausedChange({ target: { value } }: Event$1<CMedia, "state.paused">): void;
	protected handleLoadedMetadataStatus({ target: { value } }: Event$1<CMedia, "status.loadedMetadata">): void;
	activatePseudoMode(): void;
	deactivatePseudoMode(destroy?: boolean): void;
	protected onDestroy(): void;
}
export type UIOption<T> = T | {
	value: T;
	display: string;
};
export interface UISettings<T> {
	value: T;
	options: UIOption<T>[];
	[key: string]: any;
}
export interface UIConfig<T> {
	values: T[];
	displays: string[];
}
export type UIObject<T> = {
	[K in keyof T as T[K] extends object ? K : never]: T[K] extends UISettings<infer U> ? UIConfig<U> : UIObject<T[K]>;
};
declare const FN_KEY = "tmg_fn_registry";
declare const LUID_KEY = "tmg_local_uid";
declare const whiteListedKeys: readonly [
	" ",
	"enter",
	"escape",
	"arrowup",
	"arrowdown",
	"arrowleft",
	"arrowright",
	"home",
	"end",
	"0",
	"1",
	"2",
	"3",
	"4",
	"5",
	"6",
	"7",
	"8",
	"9"
];
declare const errorCodes: readonly [
	1,
	2,
	3,
	4,
	5
];
declare const modes: readonly [
	"fullscreen",
	"theater",
	"pictureInPicture",
	"miniplayer"
];
declare const controls: readonly [
	"expandminiplayer",
	"removeminiplayer",
	"meta",
	"timeline",
	"capture",
	"fullscreenorientation",
	"fullscreenlock",
	"prev",
	"playpause",
	"next",
	"brightness",
	"volume",
	"timeandduration",
	"spacer",
	"playbackrate",
	"captions",
	"settings",
	"objectfit",
	"pictureinpicture",
	"theater",
	"fullscreen"
];
declare const bigControls: readonly [
	"bigprev",
	"bigplaypause",
	"bignext"
];
declare const keyShortcutActions: readonly [
	"prev",
	"next",
	"playPause",
	"skipBwd",
	"skipFwd",
	"stepFwd",
	"stepBwd",
	"mute",
	"dark",
	"volumeUp",
	"volumeDown",
	"brightnessUp",
	"brightnessDown",
	"playbackRateUp",
	"playbackRateDown",
	"timeMode",
	"timeFormat",
	"capture",
	"objectFit",
	"pictureInPicture",
	"theater",
	"fullscreen",
	"captions",
	"captionsFontSizeUp",
	"captionsFontSizeDown",
	"captionsFontFamily",
	"captionsFontWeight",
	"captionsFontVariant",
	"captionsFontOpacity",
	"captionsBackgroundOpacity",
	"captionsWindowOpacity",
	"captionsCharacterEdgeStyle",
	"captionsTextAlignment",
	"settings"
];
declare const moddedKeyShortcutActions: readonly [
	"skip",
	"volume",
	"brightness",
	"playbackRate",
	"captionsFontSize"
];
declare const aptAutoplayOptions: string[];
declare const orientationOptions: readonly [
	"auto",
	"landscape",
	"portrait",
	"portrait-primary",
	"portrait-secondary",
	"landscape-primary",
	"landscape-secondary"
];
export type ErrorCode = (typeof errorCodes)[number];
export type Mode = (typeof modes)[number];
export type KeyShortcutAction = (typeof keyShortcutActions)[number];
export type ModdedKeyShortcutAction = (typeof moddedKeyShortcutActions)[number];
export type AptAutoplayOption = (typeof aptAutoplayOptions)[number];
export type OrientationOption = (typeof orientationOptions)[number];
export interface PosterPreview {
	usePoster: boolean;
	time: number;
	tease: boolean;
}
export interface AptRange {
	min: number;
	max: number;
	step: number;
}
export interface OptRange {
	min: number;
	max: number;
	value: number;
	skip: number;
}
export interface LightState {
	disabled: boolean;
	controls: (Control | BigControl)[] | boolean;
	preview: PosterPreview;
}
declare class LightStatePlug extends BasePlug<LightState> {
	static readonly plugName: string;
	wire(): void;
	protected handleDisabledChange({ value, target }: Event$1<VideoBuild, "lightState.disabled">): void;
	protected handleControlsChange(): void;
	protected handleUsePosterChange({ value, root }: Event$1<VideoBuild, "lightState.preview.usePoster">): void;
	protected handleTimeChange({ value, target, root }: Event$1<VideoBuild, "lightState.preview.time">): void;
	protected add(): void;
	protected remove(): void;
	protected handleLightStateClick({ target }: MouseEvent): void;
	protected stall(): void;
	protected isLight(controlId: string): boolean;
}
// NOTE: Use deep partial util where necessary after imports
export interface Captions {
	disabled: boolean;
	allowVideoOverride: boolean;
	font: {
		family: UISettings<string>;
		size: OptRange & {
			options: UIOption<number>[];
		};
		color: UISettings<string>;
		opacity: UISettings<number>;
		weight: UISettings<string | number>;
		variant: UISettings<string>;
	};
	window: {
		color: UISettings<string>;
		opacity: UISettings<number>;
	};
	background: {
		color: UISettings<string>;
		opacity: UISettings<number>;
	};
	characterEdgeStyle: UISettings<"none" | "raised" | "depressed" | "outline" | "drop-shadow">;
	textAlignment: UISettings<"left" | "center" | "right">;
}
export interface Settings {
	noOverride: keyof Settings | boolean;
	auto: Auto;
	css: Css;
	brightness: Brightness;
	captions: Captions;
	controlPanel: ControlPanel;
	errorMessages: ErrorMessages;
	fastPlay: FastPlay;
	gesture: Gesture;
	keys: {
		disabled: boolean;
		strictMatches: boolean;
		overrides: string[];
		blocks: string[];
		shortcuts: Record<KeyShortcutAction, string | string[]>;
		mods: {
			disabled: boolean;
		} & Record<ModdedKeyShortcutAction, Record<"ctrl" | "alt" | "shift", number>>;
	};
	locked: Locked;
	modes: {
		fullscreen: {
			disabled: boolean;
			orientationLock: boolean | OrientationOption;
			onRotate: boolean | number; // 0-portrait, 90-landscape, 180, 270
		};
		theater: boolean;
		pictureInPicture: {
			disabled: boolean;
			floatingPlayer: {
				disabled: boolean;
				width: number;
				height: number;
				disallowReturnToOpener: boolean;
				preferInitialWindowPlacement: boolean;
			};
		};
		miniplayer: {
			disabled: boolean;
			minWindowWidth: number;
		};
	};
	notifiers: boolean;
	overlay: Overlay;
	persist: Persist;
	playbackRate: PlaybackRate;
	playsInline: PlaysInline;
	techOrder: string[];
	time: CTime;
	toasts: Toasts;
	volume: Volume;
}
export type VideoBuild = {
	id: string;
	debug: boolean;
	disabled: boolean;
	initialMode: Mode;
	lightState: LightState;
	media: Media;
	mediaPlayer: "TMG";
	mediaType: "video";
	playlist: Playlist;
	settings: Settings;
	sources: Sources;
	src: Src;
	srcObject: SrcObject;
	tracks: Tracks;
	cloneOnDetach: boolean; // stateful issues, src resets - freezing, etc.
	noPlugList: string[]; // for non-core plugs
};
export type Src = string;
export interface Source {
	src: string;
	type: string;
	media: string;
}
export type Sources = Source[];
export type SrcObject = MediaSource | null;
export interface Track {
	kind: string;
	label: string;
	srclang: string;
	src: string;
	default: boolean;
	id: string;
}
export type Tracks = Track[];
export type PlaysInline = boolean;
export interface Media extends MediaMetadata {
	id: string;
	title: string;
	artist: string;
	profile: string;
	album: string;
	artwork: Array<{
		src: string;
		sizes: string;
		type: string;
	}>;
	chapterInfo: Array<{
		title: string;
		startTime: number;
		artwork: Array<{
			src: string;
			sizes: string;
			type: string;
		}>;
	}>;
	links: Record<"title" | "artist" | "profile", string>;
}
declare class MediaPlug extends BasePlug<Media> {
	static readonly plugName: string;
	static readonly isCore: boolean;
	mount(): void;
	wire(): void;
	protected forwardTitle(value?: string): void;
	protected forwardArtist(value?: string): void;
	protected forwardProfile(value?: string): void;
	protected handleMediaLink({ target: { key, value } }: Event$1<VideoBuild, "media.links.title" | "media.links.artist" | "media.links.profile">): void;
	protected handleArtwork({ currentTarget: { value } }: Event$1<VideoBuild, "media.artwork">): void;
	protected handleMediaChange(): void;
	syncMediaSession(): void;
}
declare class SrcPlug extends BasePlug<Src> {
	static readonly plugName: string;
	static readonly isCore: boolean;
	wire(): void;
	protected forwardSrc(value?: string): void;
}
declare class SourcesPlug extends BasePlug<Sources> {
	static readonly plugName: string;
	static readonly isCore: boolean;
	wire(): void;
	protected forwardSources(value?: Sources): void;
}
declare class SrcObjectPlug extends BasePlug<SrcObject> {
	static readonly plugName: string;
	static readonly isCore: boolean;
	wire(): void;
	protected forwardSrcObject(value?: SrcObject): void;
}
declare class TracksPlug extends BasePlug<Tracks> {
	static readonly plugName: string;
	static readonly isCore: boolean;
	wire(): void;
	protected forwardTracks(value?: Tracks): void;
}
declare class PlaysInlinePlug extends BasePlug<PlaysInline> {
	static readonly plugName: string;
	wire(): void;
	protected forwardPlaysInline(value?: boolean): void;
}
declare const timeKeys: readonly [
	"min",
	"max",
	"start",
	"end",
	"previews"
];
export type PlaylistItemTimeKey = (typeof timeKeys)[number];
export interface PlaylistItemBuild extends Pick<VideoBuild, "media" | "src" | "sources" | "tracks"> {
	settings: {
		time: Pick<Settings["time"], PlaylistItemTimeKey>;
	};
}
export type Playlist = PlaylistItemBuild[] | null;
export interface PlaylistState {
	currentIndex: number;
}
declare class PlaylistPlug extends BasePlug<Playlist, PlaylistState> {
	static readonly plugName: string;
	wire(): void;
	protected handlePlaylistChange({ root }: Event$1<VideoBuild, "playlist">): void;
	movePlaylistTo(index: number, shouldPlay?: boolean): void;
	protected applyItem(item: PlaylistItemBuild, reset?: boolean): void;
	previousVideo(): void;
	nextVideo(): void;
}
export type Css = Record<string, string | number> & {
	captionsCharacterEdgeStyle: "none" | "raised" | "depressed" | "uniform" | "dropshadow";
	captionsTextAlignment: "start" | "center" | "end";
	syncWithMedia: Record<keyof Css, boolean>;
};
declare class CSSPlug extends BasePlug<Css> {
	static readonly plugName: string;
	static readonly isCore: boolean;
	classSettings: string[];
	CSSCache: Record<string, string>;
	wire(): void;
	protected wireSheetMediators(): void;
	protected wireClassMediator(key: string): void;
	protected handleCSSChange({ type, target: { key, value } }: Event$1<VideoBuild, "settings.css">): void;
	protected getValue(key: string): string;
	protected apply(key: string, value: any): void;
	protected updateCssVariable(key: string, value: any): void;
	protected updateClass(key: string, value: any): void;
	protected wireComputedVars(): void;
	protected syncAspectRatio(): void;
	protected handleLoadedMetadataChange({ value }: Event$1<CMedia, "status.loadedMetadata">): void;
}
export interface ComponentConstructor<T extends BaseComponent = BaseComponent> {
	new (ctlr: Controller, config?: any, state?: any): T;
	componentName: string;
	isControl?: boolean;
}
export interface ComponentState {
	label: string;
	cmd: string;
	hidden: boolean;
	disabled: boolean;
}
declare abstract class BaseComponent<Config = any, State extends ComponentState = any, El extends HTMLElement = HTMLElement> extends Controllable<Config, State> {
	static readonly componentName: string;
	static readonly isControl: boolean;
	get name(): string;
	element: El;
	protected get el(): El;
	constructor(ctlr: Controller, config: Config, state?: State);
	protected onSetup(): void;
	protected onDestroy(): void;
	abstract create(): El;
	mount?(): void;
	unmount(): void;
	wire?(): void;
	hide(): void;
	show(): void;
	disable(): void;
	enable(): void;
	protected getIcon(name: string): string;
	protected setBtnARIA(doubleKeyAction?: string): void;
}
export type Control = (typeof controls)[number];
export type SControl = Control | "spacer";
export type BigControl = (typeof bigControls)[number];
export type ControlPanelBottomTuple = Record<1 | 2 | 3, SControl[]>;
export interface ControlPanel {
	profile: string | boolean;
	title: string | boolean;
	artist: string | boolean;
	top: SControl[] | boolean;
	center: BigControl[] | boolean;
	bottom: boolean | SControl[] | SControl[][] | Partial<ControlPanelBottomTuple>;
	buffer: "eclipse" | "accent" | boolean;
	timeline: {
		thumbIndicator: boolean;
		seek: {
			relative: boolean;
			cancel: {
				delta: number;
				timeout: number;
			};
		};
	};
	progressBar: boolean;
	draggable: ("" | "big" | "wrapper")[] | boolean;
}
export type ZoneW = {
	cover?: HTMLElement;
	zone: HTMLElement;
};
export type Row = 1 | 2 | 3;
declare class ControlPanelPlug extends BasePlug<ControlPanel> {
	static readonly plugName: string;
	static readonly isCore: boolean;
	controls: Map<string, {
		element: HTMLElement;
		instance?: BaseComponent<any, any>;
	}>;
	getControl<T extends BaseComponent = BaseComponent>(name: string): T | undefined;
	getControlEl<T extends HTMLElement = HTMLElement>(name: string): T | undefined;
	protected zoneWs: {
		top: Record<"left" | "center" | "right", ZoneW>;
		center: ZoneW;
		bottom: Record<Row, Record<"left" | "center" | "right", ZoneW>>;
	};
	protected cZoneWs: {
		top: Record<"left" | "center" | "right", ZoneW>;
		center: ZoneW;
		bottom: Record<Row, Record<"left" | "center" | "right", ZoneW>>;
	};
	protected dragging: HTMLElement | null;
	protected dragReplaced: {
		target: HTMLElement;
		child: HTMLElement;
	} | null;
	protected dragSafeTimeoutId: number;
	mount(): void;
	wire(): void;
	protected buildWSkel(side: string): ZoneW;
	protected getSplitControls(row: SControl[]): {
		left: SControl[];
		center: SControl[];
		right: SControl[];
	};
	protected fillZone(zoneW: ZoneW, ids: SControl[] | BigControl[]): void;
	protected getZones(): HTMLElement[];
	protected handleTopLayout({ target: { value } }: Event$1<VideoBuild, "settings.controlPanel.top">): void;
	protected handleCenterLayout({ target: { value } }: Event$1<VideoBuild, "settings.controlPanel.center">): void;
	protected handleBottomLayout({ target: { value } }: Event$1<VideoBuild, "settings.controlPanel.bottom">): void;
	protected getDraggableControls(): NodeListOf<HTMLElement>;
	protected getDropZones(): HTMLElement[];
	protected setDragEventListeners(action: "add" | "remove"): void;
	protected getUIZoneWCoord(target: HTMLElement, zoneW?: boolean): string | {
		coord: string;
		zoneW: ZoneW;
	};
	protected syncControlPanelToUI(): void;
	protected noDropOff(t: HTMLElement, drop?: HTMLElement | null): boolean;
	protected handleDragStart(e: DragEvent): void;
	protected handleDrag(): void;
	protected handleDragEnd(e: DragEvent): void;
	protected handleDragEnter(e: DragEvent): void;
	protected handleDragOver(e: DragEvent): void;
	protected handleDrop(e: DragEvent): void;
	protected handleDragLeave(e: DragEvent): void;
	protected onDestroy(): void;
}
export interface Overlay {
	delay: number;
	curtain: "cover" | "auto";
	behavior: "persistent" | "auto" | "strict" | "hidden";
}
export interface OverlayState {
	visible: boolean;
}
declare class OverlayPlug extends BasePlug<Overlay, OverlayState> {
	static readonly plugName: string;
	overlayDelayId: number;
	constructor(ctlr: Controller, config: Overlay);
	wire(): void;
	protected handleCurtain({ target: { value } }: Event$1<VideoBuild, "settings.overlay.curtain">): void;
	protected handleBehavior({ target: { value } }: Event$1<VideoBuild, "settings.overlay.behavior">): void;
	shouldShow(): boolean;
	shouldRemove(manner?: "force"): boolean;
	show(): void;
	delay(): void;
	remove(manner?: "force"): void;
}
export interface StorageAdapterConstructor {
	new (namespace: string): StorageAdapter;
}
export declare abstract class StorageAdapter {
	readonly namespace: string;
	constructor(namespace: string);
	abstract get(key: string): any;
	abstract set(key: string, value: any): void;
	abstract remove(key: string): void;
}
export declare class LocalStorageAdapter extends StorageAdapter {
	get(key: string): any;
	set(key: string, value: any): void;
	remove(key: string): void;
}
export interface Persist {
	disabled: boolean;
	adapter: StorageAdapterConstructor;
	throttle: number;
}
declare class PersistPlug extends BasePlug<Persist> {
	static readonly plugName: string;
	protected adapter: StorageAdapter;
	wire(): void;
	protected handleAdapterChange({ value }: Event$1<VideoBuild, "settings.persist.adapter">): void;
	protected handleDisabledChange({ value }: Event$1<VideoBuild, "settings.persist.disabled">): void;
	protected throttleSave({ root: { settings } }: Event$1<VideoBuild, "settings">): void;
	protected onDestroy(): void;
}
declare class Buffer$1 extends BaseComponent {
	static componentName: string;
	create(): HTMLElement;
}
export type DurationConfig = undefined;
declare class Duration extends BaseComponent<DurationConfig, ComponentState, HTMLButtonElement> {
	static readonly componentName: string;
	static readonly isControl: boolean;
	protected plug?: TimePlug;
	create(): HTMLButtonElement;
	wire(): void;
	protected updateUI(): void;
	protected updateARIA(): void;
}
export type PlayPauseConfig = undefined;
declare class PlayPause extends BaseComponent<PlayPauseConfig, ComponentState, HTMLButtonElement> {
	static readonly componentName: string;
	static readonly isControl: boolean;
	create(): HTMLButtonElement;
	wire(): void;
	protected updateUI(): void;
	protected updateARIA(): void;
	protected togglePlay(): void;
}
export interface RangeConfig extends AptRange {
	value: number;
	previewValue: number;
	label: string;
	scrub: {
		sync: boolean;
		relative: boolean;
		cancel: {
			delta: number;
			timeout: number;
		};
	};
	wheel: {
		disabled: boolean;
		axisRatio: number;
	};
}
export interface RangeState extends ComponentState {
	scrubbing: boolean;
	shouldCancelScrub: boolean;
	stallCancelScrub: boolean;
}
declare class RangeSlider<Config extends RangeConfig = RangeConfig, State extends RangeState = RangeState> extends BaseComponent<Reactive<Config>, State> {
	config: Reactive<Config> & Reactive<RangeConfig>;
	static readonly componentName: string;
	protected container: HTMLElement;
	protected barsWrapper: HTMLElement;
	protected baseBar: HTMLElement;
	protected valueBar: HTMLElement;
	protected thumbIndicator: HTMLElement;
	protected lastPointerP: number;
	protected lastThumbPosition: number;
	protected cancelScrubTimeoutId: number | null;
	protected rect: DOMRect;
	protected isVertical: boolean;
	protected isRTL: boolean;
	constructor(ctlr: Controller, options?: Partial<Config>);
	create(): HTMLElement;
	wire(): void;
	protected seek(value: number): void;
	protected handleValueChange({ target }: Event$1<RangeConfig, "value">): void;
	protected handlePointerDown(e: PointerEvent): void;
	protected stopScrubbing(): void;
	protected stopPreview(): void;
	protected cancelScrubbing(): void;
	protected allowScrubbing(reset?: boolean): void;
	protected handleInput(e: MouseEvent | PointerEvent): void;
	protected onInput(e: MouseEvent | PointerEvent, pos: number): void;
	protected handleWheel(e: WheelEvent): void;
	protected handleKeyDown: (e: KeyboardEvent) => void;
	protected updateThumbPosition(pos: number): void;
	protected updateValueBar(pos: number): void;
	protected getValueAsPos(value?: number): number;
	protected getPosAsValue(pos: number): number;
	protected getPos(e: MouseEvent | PointerEvent): number;
}
export type ScreenLockedConfig = undefined;
declare class ScreenLocked extends BaseComponent<ScreenLockedConfig, ComponentState, HTMLButtonElement> {
	static readonly componentName: string;
	protected plug?: LockedPlug;
	create(): HTMLButtonElement;
	wire(): void;
	protected updateUI(): void;
	protected handleClick(e: MouseEvent): void;
}
export type TimeConfig = undefined;
declare class Time extends BaseComponent<TimeConfig, ComponentState, HTMLButtonElement> {
	static readonly componentName: string;
	static readonly isControl: boolean;
	protected plug?: TimePlug;
	create(): HTMLButtonElement;
	wire(): void;
	protected updateUI(): void;
	protected updateARIA(): void;
}
export type TimeAndDurationConfig = undefined;
declare class TimeAndDuration extends BaseComponent<TimeAndDurationConfig, ComponentState, HTMLButtonElement> {
	static readonly componentName: string;
	static readonly isControl: boolean;
	protected plug?: TimePlug;
	protected time: HTMLElement;
	protected bridge: HTMLElement;
	protected duration: HTMLElement;
	create(): HTMLButtonElement;
	wire(): void;
	protected updateUI(): void;
	protected updateTime(): void;
	protected updateDuration(): void;
	protected updateARIA(): void;
}
export type PreviewConfig = boolean | {
	address?: string;
	cols?: number;
	rows?: number;
	spf?: number;
	type?: "sprite" | "image" | "canvas" | "none";
};
export interface TimelineConfig extends RangeConfig {
	previews: PreviewConfig;
}
declare class Timeline extends RangeSlider<TimelineConfig> {
	static readonly componentName: string;
	static readonly isControl: boolean;
	protected plug?: TimePlug;
	protected timeline: HTMLElement;
	protected previewContainer: HTMLElement;
	protected previewImg: HTMLElement;
	protected previewCanvas: HTMLCanvasElement;
	protected thumbnailImg: HTMLElement;
	protected thumbnailCanvas: HTMLCanvasElement;
	protected bufferedBar: HTMLElement;
	protected previewBar: HTMLElement;
	protected previewContext: CanvasRenderingContext2D | null;
	protected thumbnailContext: CanvasRenderingContext2D | null;
	constructor(ctlr: Controller, options?: Partial<TimelineConfig>);
	create(): HTMLElement;
	mount(): void;
	wire(): void;
	protected seek(value: number): void;
	protected handleLoadedMetadata(): void;
	protected handleTimeUpdate({ target }: Event$1<CMedia, "state.currentTime">): void;
	protected handleProgress(): void;
	protected handleDurationChange({ target }: Event$1<CMedia, "status.duration">): void;
	protected handleScrubbingChange({ target }: Event$1<RangeState, "scrubbing">): void;
	protected handlePreviewChange({ target }: Event$1<TimelineConfig, "previews">): void;
	stopScrubbing(): void;
	protected stopPreview(): void;
	protected onInput(e: MouseEvent | PointerEvent, pos: number): void;
	protected updatePreviewTime(): void;
	protected syncCanvasPreviews(): void;
	protected syncThumbnailSize(): void;
}
export type Locked = {
	disabled: boolean;
};
export interface LockedState {
	visible: boolean;
}
declare class LockedPlug extends BasePlug<Locked, LockedState> {
	static readonly plugName: string;
	lockOverlayDelayId: number;
	protected btnComponent?: ScreenLocked;
	constructor(ctlr: Controller, config: Locked);
	mount(): void;
	wire(): void;
	protected injectLockedWrapper(): void;
	protected injectScreenLockedBtn(): void;
	protected handleScreenClick(): void;
	protected handleLockChange({ target: { value } }: Event$1<VideoBuild, "settings.locked.disabled">): Promise<void>;
	showOverlay(): void;
	removeOverlay(): void;
	delayOverlay(): void;
	protected onDestroy(): void;
}
export interface CTime extends OptRange {
	mode: "elapsed" | "remaining";
	format: "digital" | "human" | "human-long";
	start: number | null | undefined;
	end: number;
	loop: boolean;
	previews?: Omit<PreviewConfig, "type"> | boolean;
	seekSync: boolean;
}
declare class TimePlug extends BasePlug<CTime> {
	static readonly plugName: string;
	private actualStart;
	private pseudoStart;
	private skipDuration;
	private skipDurationId;
	private currentSkipNotifier;
	wire(): void;
	protected forwardTimeValue(value?: number): void;
	protected handleTimeUpdate({ target }: Event$1<CMedia, "state.currentTime">): void;
	protected handleWaitingStatus({ target: { value } }: Event$1<CMedia, "status.waiting">): void;
	toTimeVal(value: number | string | undefined | null): number;
	toTimeText(time?: number, useMode?: boolean, showMs?: boolean): string;
	get nextMode(): CTime["mode"];
	toggleMode(): void;
	get nextFormat(): CTime["format"];
	rotateFormat(): void;
	skip(duration: number): void;
}
/**
 * HISTORY ENTRY: The DNA of a specific moment in time.
 * Records the 'Desire' (Intent) or the 'Fact' (State).
 */
export interface HistoryEntry {
	type: string;
	path: string;
	value: any;
	phase: number;
	rejected: string;
	timestamp: number;
}
export type TimeTravel = undefined;
declare class TimeTravelPlug extends BasePlug<TimeTravel> {
	static plugName: string;
	protected history: HistoryEntry[];
	protected initialState: any;
	protected isReplaying: boolean;
	protected stopRequested: boolean;
	protected currentFrame: number;
	protected playbackTimer: any;
	protected onSetup(): void;
	/**
	 * RECORD: Chronicling the lifecycle of the system.
	 */
	protected record(e: Event$1<any>): void;
	exportSession(): string;
	loadSession(json: string): void;
	/**
	 * PLAY SESSION: Chronological re-enactment.
	 * Replays the "Story" by respecting the delays between events.
	 */
	playSession(): Promise<void>;
	pauseSession(): void;
	/**
	 * JUMP TO (Teleport): Instant state reconstruction.
	 * Collapses history into a single "Truth" map and injects it.
	 */
	jumpTo(index: number): void;
	step(forward?: boolean): void;
	/**
	 * REWIND (The Ctrl+Z): Destructive undo.
	 * Pops history entries and teleports the world to the new tail.
	 */
	rewind(steps?: number): void;
	/**
	 * APPLY ENTRY: Internal dispatcher for single-event re-enactment.
	 */
	protected applyEntry(e: HistoryEntry): void;
}
export interface WheelConfig {
	volume: {
		normal: boolean;
		slider: boolean;
	};
	brightness: {
		normal: boolean;
		slider: boolean;
	};
	timeline: {
		normal: boolean;
		slider: boolean;
	};
	timeout: number;
	xRatio: number;
	yRatio: number;
}
declare class WheelModule extends BaseModule<WheelConfig> {
	static readonly moduleName: string;
	protected timeoutId: number | null;
	protected zone: {
		x: "left" | "right";
		y: "top" | "bottom";
	} | null;
	protected xCheck: boolean;
	protected yCheck: boolean;
	protected timePercent: number;
	protected timeMultiplier: number;
	protected deltaY: number;
	protected nextTime: number;
	wire(): void;
	protected canHandle(e: WheelEvent): boolean;
	protected handleWheel(e: WheelEvent): void;
	protected handleInit({ clientX: x, clientY: y }: WheelEvent): void;
	protected handleMove({ clientX: x, deltaX, deltaY, shiftKey }: WheelEvent): void;
	protected handleStop(): void;
	protected applyTimeline(percent: number, sign: string, multiplier: number): void;
	protected applyRange(key: "volume" | "brightness", percent: number, sign: string): void;
}
export interface TouchConfig {
	volume: boolean;
	brightness: boolean;
	timeline: boolean;
	threshold: number;
	sliderTimeout: number;
	xRatio: number;
	yRatio: number;
	axesRatio: number;
	inset: number;
}
declare class TouchModule extends BaseModule<TouchConfig> {
	static readonly moduleName: string;
	protected lastX: number;
	protected lastY: number;
	protected zone: {
		x: "left" | "right";
		y: "top" | "bottom";
	} | null;
	protected xCheck: boolean;
	protected yCheck: boolean;
	protected canCancel: boolean;
	protected cancelTimeoutId: number;
	protected sliderTimeoutId: number;
	protected nextTime: number;
	wire(): void;
	protected canHandle(e: TouchEvent): boolean;
	protected handleStart(e: TouchEvent): void;
	protected handleInit(e: Event): void;
	protected handleXMove(e: Event): void;
	protected handleYMove(e: Event): void;
	protected handleEnd(): void;
	protected applyTimeline({ percent, sign, multiplier }: {
		percent: number;
		sign: string;
		multiplier: number;
	}): void;
	protected applyRange(key: "volume" | "brightness", percent: number, sign: string): void;
}
export interface GeneralConfig {
	click: string;
	dblClick: string;
}
declare class GeneralModule extends BaseModule<GeneralConfig> {
	static readonly moduleName: string;
	protected focusSubjectId: string;
	protected skipPersistPosition: "left" | "right" | null;
	wire(): void;
	protected handleAnyClick(): void;
	protected handleRightClick(e: MouseEvent): void;
	protected handleFocusIn({ target }: FocusEvent): void;
	protected handleKeyFocusIn({ target }: KeyboardEvent): void;
	protected handleHoverPointerActive(e: Event): void;
	protected handleHoverPointerOut(): void;
	protected handleClick(e: MouseEvent): void;
	protected handleDblClick(e: MouseEvent): void;
	activateSkipPersist(pos: "left" | "right"): void;
	deactivateSkipPersist(): void;
}
export type Gesture = {
	click: string;
	dblClick: string;
	wheel: WheelConfig;
	touch: TouchConfig;
};
declare class GesturePlug extends BasePlug<Gesture> {
	static readonly plugName: string;
	general: GeneralModule;
	wheel: WheelModule;
	touch: TouchModule;
	constructor(ctlr: Controller, config: Gesture, state?: any);
	wire(): void;
	protected onDestroy(): void;
}
export interface Volume extends OptRange {
	muted: boolean;
}
declare class VolumePlug extends BasePlug<Volume> {
	static readonly plugName: string;
	protected lastVolume: number;
	protected sliderAptVolume: number;
	protected shouldMute: boolean;
	protected shouldSetLastVolume: boolean;
	protected audioSetup: boolean;
	protected gainNode?: GainNode;
	get ctime(): number;
	mount(): void;
	wire(): void;
	protected setupAudio(): void;
	protected cancelAudio(): void;
	protected handleVolumeState(volume: number): void;
	protected handleMutedState(muted: boolean): void;
	protected forwardVolume(value?: number): void;
	protected forwardMuted(value?: boolean): void;
	protected handleVolumeIntent(e: Event$1<CMedia, "intent.volume">): void;
	protected handleMutedIntent(e: Event$1<CMedia, "intent.muted">): void;
	protected handleMinChange({ target }: Event$1<VideoBuild, "settings.volume.min">): void;
	protected handleMaxChange({ target }: Event$1<VideoBuild, "settings.volume.max">): void;
	toggleMute(option?: "auto"): void;
	changeVolume(value: number): void;
	handleSliderInput(volume: number): void;
	protected handleNativeVolumeChange: () => void;
}
export interface PlaybackRate extends OptRange {
}
declare class PlaybackRatePlug extends BasePlug<PlaybackRate> {
	static readonly plugName: string;
	wire(): void;
	protected forwardRate(value?: number): void;
	protected handleMinChange({ target }: Event$1<VideoBuild, "settings.playbackRate.min">): void;
	protected handleMaxChange({ target }: Event$1<VideoBuild, "settings.playbackRate.max">): void;
	rotateRate(dir?: "forwards" | "backwards"): void;
	changeRate(value: number): void;
}
export interface Brightness extends OptRange {
	dark: boolean;
}
declare class BrightnessPlug extends BasePlug<Brightness> {
	static readonly plugName: string;
	protected lastBrightness: number;
	protected sliderAptBrightness: number;
	protected shouldDark: boolean;
	protected shouldSetLastBrightness: boolean;
	wire(): void;
	protected handleBrightnessState(value: number): void;
	protected handleDarkState(dark: boolean): void;
	protected handleBrightnessChange({ target: { value } }: Event$1<VideoBuild, "settings.brightness.value">): void;
	protected handleDarkChange({ oldValue, value: dark }: Event$1<VideoBuild, "settings.brightness.dark">): void;
	protected handleMinChange({ target }: Event$1<VideoBuild, "settings.brightness.min">): void;
	protected handleMaxChange({ target }: Event$1<VideoBuild, "settings.brightness.max">): void;
	toggleDark(option?: "auto"): void;
	changeBrightness(value: number): void;
	handleSliderInput(brightness: number): void;
}
export interface Auto {
	play: boolean | AptAutoplayOption;
	pause: boolean | AptAutoplayOption;
	next: {
		value: number;
		videoPreview: PosterPreview;
	};
}
declare class AutoPlug extends BasePlug<Auto> {
	static readonly plugName: string;
	protected nextVideoPreview: HTMLVideoElement | null;
	protected canAutoMovePlaylist: boolean;
	wire(): void;
	protected forwardAutoPlay(value?: boolean | AptAutoplayOption): void;
	protected handleIntersectionChange(): void;
	protected handleTimeUpdate({ target }: Event$1<CMedia, "state.currentTime">): void;
	protected handleUsePoster({ target: { value } }: Event$1<VideoBuild, "settings.auto.next.videoPreview.usePoster">): void;
	protected handleTease({ target: { value } }: Event$1<VideoBuild, "settings.auto.next.videoPreview.tease">): void;
	protected handlePreviewTime({ target: { value } }: Event$1<VideoBuild, "settings.auto.next.videoPreview.time">): void;
	protected handleMediaAptAutoPlay(auto?: string | boolean, bool?: boolean, p?: string): void;
	protected autonextVideo: () => void;
}
// === Type definition for T007 Toast Library (Global) ===
export type ToastType = "success" | "error" | "warning" | "info";
export type ToastOptions = Partial<{
	id: string;
	idPrefix: string;
	render: string;
	type: ToastType;
	image: string | boolean;
	icon: string;
	autoClose: boolean | number; //
	position: "top-right" | "top-left" | "top-center" | "bottom-right" | "bottom-left" | "bottom-center" | "cetner-right" | "center-left" | "center-center";
	onClose: (timeElapsed: boolean) => void;
	onTimeUpdate: (time: number) => void;
	closeButton: boolean;
	closeOnClick: boolean;
	isLoading: boolean | string; // icon HTML
	nprogress: number;
	dragToClose: boolean | "mouse" | "touch" | "pen";
	dragToClosePercent: number | {
		x: number;
		y: number;
	};
	dragToCloseDir: "x" | "y" | "xy" | "x|y" | "x||y" | "x+" | "x-" | "y+" | "y-" | "xy+" | "xy-" | "x|y+" | "x|y-" | "x||y+" | "x||y-";
	hideProgressBar: boolean;
	pauseOnHover: boolean;
	pauseOnFocusLoss: boolean;
	renotify: boolean;
	tag: string | number;
	vibrate: boolean | number[];
	delay: number;
	bodyHTML: string;
	animation: "fade" | "zoom" | "slide" | "slide-left" | "slide-right" | "slide-up" | "slide-down";
	actions: Record<string, () => void>;
	rootElement: any; // HTMLElement
	maxToasts: number;
	newestOnTop: boolean;
}>;
export interface ToastInstance {
	(message: string, options?: ToastOptions): string; // returns toast ID
	loading(message: string, options?: ToastOptions): string;
	success(renderOrId: string, options?: ToastOptions): string;
	error(renderOrId: string, options?: ToastOptions): string;
	warn(renderOrId: string, options?: ToastOptions): string;
	dismiss(id: string, manner?: "instant" | "animate"): void;
	dismissAll(idPrefix?: string): void;
	doForAll(action: string, payload: any, idPrefix?: string): void;
	getAll(idPrefix: string): ToastInstance[];
}
export interface Toasts extends ToastOptions {
	disabled: boolean;
	captureAutoClose: number;
}
declare class ToastsPlug extends BasePlug<Toasts> {
	static readonly plugName: string;
	wire(): void;
	protected handleDisabled({ target: { value } }: Event$1<VideoBuild, "settings.toasts.disabled">): void;
	protected handleToastUpdate({ type, target: { path, key, value } }: Event$1<VideoBuild, "settings.toasts">): void;
	get toast(): ToastInstance | null;
}
export interface FastPlay {
	playbackRate: number;
	key: boolean;
	pointer: {
		type: string;
		threshold: number;
		inset: number;
	};
	reset: boolean;
	rewind: boolean;
}
export interface FastPlayState {
	speedValue: number;
	isRewinding: boolean;
}
declare class FastPlayPlug extends BasePlug<FastPlay, FastPlayState> {
	static readonly plugName: string;
	protected speedCheck: boolean;
	protected wasPaused: boolean;
	protected lastPlaybackRate: number;
	protected rewindPlaybackRate: number;
	protected speedIntervalId: number | null;
	protected speedPointerCheck: boolean;
	protected speedDirection: "forwards" | "backwards";
	protected speedTimeoutId: number | null;
	protected playTriggerCounter: number;
	wire(): void;
	fastPlay(pos: "forwards" | "backwards"): void;
	fastForward(rate?: number): void;
	rewind(rate?: number): void;
	protected rewindVideo(): void;
	protected rewindReset(): void;
	slowDown(): void;
	protected handleSpeedPointerDown(e: PointerEvent): void;
	protected handleSpeedPointerMove(e: Event): void;
	protected handleSpeedPointerUp(): void;
	protected handleSpeedPointerOut(): void;
}
export type ErrorMessages = Record<ErrorCode, string>;
declare class ErrorMessagesPlug extends BasePlug<ErrorMessages> {
	static readonly plugName: string;
	wire(): void;
	protected handleError({ target: { value } }: Event$1<CMedia, "status.error">): void;
}
export type BaseTechConfig = Reactive<CMedia>;
export interface TechConstructor<T extends BaseTech = BaseTech> {
	new (ctlr: Controller, config: any): T;
	techName: string;
	features: MediaFeatures;
	canPlaySource(src: string): boolean;
}
declare abstract class BaseTech<Config extends BaseTechConfig = BaseTechConfig, El extends HTMLElement = HTMLElement> extends Controllable<Config> {
	static readonly techName: string;
	get name(): string;
	static readonly features: MediaFeatures;
	get features(): MediaFeatures;
	element: HTMLElement;
	protected get el(): El;
	constructor(ctlr: Controller, config: Config);
	onSetup(): void;
	onDestroy(): void;
	static canPlaySource(src: string): boolean;
	mount(): void;
	unmount(): void;
	wire(): void;
	protected abstract wireSrc(): void;
	protected abstract wireCurrentTime(): void;
	protected abstract wireDuration(): void;
	protected abstract wirePaused(): void;
	protected abstract wireEnded(): void;
	protected wireFeatures(): void;
	protected wireVolume?(): void;
	protected wireMuted?(): void;
	protected wirePlaybackRate?(): void;
	protected wirePictureInPicture?(): void;
	protected wireFullscreen?(): void;
	protected wireAirplay?(): void;
	protected wireChromecast?(): void;
	protected wireXRSession?(): void;
	protected wireXRMode?(): void;
	protected wireXRReferenceSpace?(): void;
	protected wireProjection?(): void;
	protected wireStereoMode?(): void;
	protected wireFieldOfView?(): void;
	protected wireAspectRatio?(): void;
	protected wirePanningX?(): void;
	protected wirePanningY?(): void;
	protected wirePanningZ?(): void;
	protected wireXRInputSource?(): void;
	protected wireAutoLevel?(): void;
	protected wireCurrentLevel?(): void;
	protected wireCurrentAudioTrack?(): void;
	protected wireCurrentVideoTrack?(): void;
	protected wireCurrentTextTrack?(): void;
	protected wirePoster?(): void;
	protected wireAutoplay?(): void;
	protected wireLoop?(): void;
	protected wirePreload?(): void;
	protected wirePlaysInline?(): void;
	protected wireCrossOrigin?(): void;
	protected wireControls?(): void;
	protected wireControlsList?(): void;
	protected wireDisablePictureInPicture?(): void;
	protected wireSources?(): void;
	protected wireTracks?(): void;
}
declare class HTML5Tech extends BaseTech<BaseTechConfig, HTMLVideoElement> {
	static readonly techName: string;
	static readonly features: MediaFeatures;
	private static readonly DUMMY;
	protected readonly eOpts: {
		EL: AddEventListenerOptions;
		REACTOR: ListenerOptions;
	};
	static canPlaySource(src: string): boolean;
	constructor(ctlr: Controller, config: BaseTechConfig);
	protected wireSrc(): void;
	protected wireCurrentTime(): void;
	protected wireDuration(): void;
	protected wirePaused(): void;
	protected wireEnded(): void;
	protected wireFeatures(): void;
	protected wireVolume(): void;
	protected wireMuted(): void;
	protected wirePlaybackRate(): void;
	protected wirePictureInPicture(): void;
	protected wireFullscreen(): void;
	protected wireCurrentTrack(type: TrackType): void;
	protected wireCurrentAudioTrack(): void;
	protected wireCurrentVideoTrack(): void;
	protected wireCurrentTextTrack(): void;
	protected wireHTMLState(): void;
	protected bindAttr<K extends keyof MediaIntent>(key: K, isBool?: boolean): void;
	protected wirePoster(): void;
	protected wireAutoplay(): void;
	protected wireLoop(): void;
	protected wirePreload(): void;
	protected wirePlaysInline(): void;
	protected wireCrossOrigin(): void;
	protected wireControls(): void;
	protected wireControlsList(): void;
	protected wireDisablePictureInPicture(): void;
	protected wireSources(): void;
	protected wireTracks(): void;
	protected wireTracksStatus(type: "textTracks" | "videoTracks" | "audioTracks"): void;
	protected wireActiveCueStatus(): void;
	protected wireDefaultMuted(): void;
	protected wireDefaultPlaybackRate(): void;
	protected handleLoadStartState(): void;
	protected handleTimeUpdateState(): void;
	protected handleSeekingState(): void;
	protected handleSeekedState(): void;
	protected handleDurationChangeState(): void;
	protected handlePlayState(): void;
	protected handlePauseState(): void;
	protected handleEndedState(): void;
	protected handleSrcIntent(e: Event$1<CMedia, "intent.src">): void;
	protected handleCurrentTimeIntent(e: Event$1<CMedia, "intent.currentTime">): void;
	protected handlePausedIntent(e: Event$1<CMedia, "intent.paused">): void;
	protected handleVolumeChangeState(): void;
	protected handleRateChangeState(): void;
	protected handleEnterPiPState(): void;
	protected handleLeavePiPState(): void;
	protected handleFullscreenChangeState(docInFs?: boolean): void;
	protected handleWebkitBeginFullscreenState(): void;
	protected handleWebkitEndFullscreenState(): void;
	protected handleCurrentTrackState(type: TrackType, list: any): void;
	protected handleHTMLState(mutations: MutationRecord[]): string | boolean | DOMTokenList | null | undefined;
	protected handleVolumeIntent(e: Event$1<CMedia, "intent.volume">): void;
	protected handleMutedIntent(e: Event$1<CMedia, "intent.muted">): void;
	protected handlePlaybackRateIntent(e: Event$1<CMedia, "intent.playbackRate">): void;
	protected handlePiPIntent(e: Event$1<CMedia, "intent.pictureInPicture">): void;
	protected handleFullscreenIntent(e: Event$1<CMedia, "intent.fullscreen">): void;
	protected handleCurrentTrackIntent(e: Event$1<CMedia, `intent.current${TrackType}Track`>, type: TrackType): void;
	protected handleAttributeIntent(e: Event$1<CMedia, WCPaths<CMedia>>, key: string, isBool: boolean): void;
	protected handleSourcesIntent(e: Event$1<CMedia, "intent.sources">): void;
	protected handleTracksIntent(e: Event$1<CMedia, "intent.tracks">): void;
	protected handleLoadStatus(): void;
	protected handleLoadedMetadataStatus(): void;
	protected handleLoadedDataStatus(): void;
	protected handleCanPlayStatus(): void;
	protected handleCanPlayThroughStatus(): void;
	protected handleStalledStatus(): void;
	protected handleWaitingStatus(): void;
	protected handlePlayingStatus(): void;
	protected handleErrorStatus(): void;
	protected handleTracksStatus(type: "textTracks" | "videoTracks" | "audioTracks", list: any): void;
	protected handleActiveCueStatus(e?: globalThis.Event | {
		target?: TextTrack;
	}): void;
	protected handleDefaultMutedSetting(e: Event$1<CMedia, "settings.defaultMuted">): void;
	protected handleDefaultPlaybackRateSetting(e: Event$1<CMedia, "settings.defaultPlaybackRate">): void;
	protected static canControlVolume(): boolean;
	protected static canMuteVolume(): boolean;
	protected static canControlRate(): boolean;
	protected static supportsTextTracks(): boolean;
	protected static supportsVideoTracks(): boolean;
	protected static supportsAudioTracks(): boolean;
}
export interface MediaContract {
	// "Must Haves" to be even considered media
	src: Src;
	currentTime: number;
	duration: number;
	paused: boolean;
	ended: boolean;
}
export interface MediaState {
	// --- The Big Three (Promise-based State) ---
	src: MediaContract["src"]; // Rejects if network fails or format unsupported
	currentTime: MediaContract["currentTime"]; // Rejects if outside seekable range
	paused: MediaContract["paused"]; // Rejects if "Autoplay Policy" denies it
	// --- The Engine Inputs (Interceptable) ---
	volume: number;
	muted: boolean;
	playbackRate: number;
	// --- The Presentation Modes (Heavily Rejectable) ---
	pictureInPicture: boolean;
	fullscreen: boolean;
	// --- Casting (Connection Handshakes) ---
	airplay: boolean; // Apple AirPlay
	chromecast: boolean; // Google Cast
	// --- VR / XR (Spatial Realities) ---
	xrSession: boolean; // Request "Immersive Mode" (Handshake)
	xrMode: "inline" | "immersive-vr" | "immersive-ar"; // Hardware target
	xrReferenceSpace: "local" | "local-floor" | "bounded-floor" | "unbounded";
	// --- Projection & Stereo (The "Content" Logic) ---
	projection: "flat" | "equirectangular" | "cubemap" | "cylindrical";
	stereoMode: "mono" | "sbs" | "top-bottom" | "vr180" | "none"; // Side-by-Side vs Top-Bottom
	// --- Camera & Viewport (The "Lens") ---
	fieldOfView: number; // Degrees (Vertical FOV)
	aspectRatio: number; // Viewport ratio
	// --- Orientation (The "Head/Camera" Pose) ---
	panningX: number; // Yaw (Left/Right)
	panningY: number; // Pitch (Up/Down)
	panningZ: number; // Roll (Tilt/Barrel)
	// --- Interaction (XR Controllers) ---
	xrInputSource: any; // Reference to active controllers/hand-tracking
	// --- Track Switching (Async Buffering/Streaming) ---
	// NOTE: "Disabled" value is "-1"
	currentTextTrack: number; // Subtitle
	currentAudioTrack: number; // Language (English -> Spanish)
	currentVideoTrack: number; // Angle
	autoLevel: boolean; // ABR Algorithm enabled?
	currentLevel: number; // Quality (1080p -> 4K)
	// --- HTML Attributes ---
	poster: string;
	autoplay: boolean;
	loop: boolean;
	preload: "" | "auto" | "metadata" | "none";
	playsInline: boolean;
	crossOrigin: "anonymous" | "use-credentials" | string | null;
	controls: boolean; // Native controls enabled?
	controlsList: DOMTokenList | string | null; // Native controls disabled (e.g. "nodownload")
	disablePictureInPicture: boolean;
	// ---  HTML Lists ---
	sources: Sources; // HTML courtesy
	tracks: Tracks; // HTML courtesy
}
export interface MediaIntent extends MediaState {
	currentLevel: any;
	currentAudioTrack: any;
	currentVideoTrack: any;
	currentTextTrack: any;
} // Tech's responsibility to receive `any` intent and produce a `number` that can index their status (track/level) lists
export interface MediaStatus {
	// --- Network & Health ---
	readyState: number;
	networkState: number;
	error: MediaError | null;
	bandwidth: number | null; // Estimated Mbps
	// --- Buffering & Time ---
	waiting: boolean; // Spinner Active?
	stalled: boolean; // Network died?
	seeking: boolean; // Scrubbing?
	buffered: TimeRanges;
	played: TimeRanges;
	seekable: TimeRanges;
	duration: MediaContract["duration"]; // In seconds
	ended: MediaContract["ended"]; // Playback complete?
	// --- Dimensions ---
	videoWidth: number;
	videoHeight: number;
	// --- Lifecycle Gates ---
	loadedMetadata: boolean; // Do we know duration?
	loadedData: boolean; // Can we render frame 1?
	canPlay: boolean; // Can we start?
	canPlayThrough: boolean; // Can we finish?
	// --- Lists ---
	textTracks: TextTrackList | any[];
	audioTracks: any[]; // | AudioTrackList
	videoTracks: any[]; // | VideoTrackList
	levels: any[];
	// --- VR / XR Info ---
	xrCapabilities: Record<"hasPosition" | "hasOrientation" | "isEmulated", // 6DoF- Room-scale, 3DoF- Head rotation, Emulated- Magic Window
	boolean> | null;
	// --- Active Content ---
	activeCue: TextTrackCue | null; // The current subtitle/caption line
}
export interface MediaSettings {
	// --- Defaults (Startup values) ---
	defaultMuted: boolean;
	defaultPlaybackRate: number;
	// --- Stream Sources ---
	srcObject: SrcObject; // HTML courtesy
}
export type MediaFeatures = {
	[K in Exclude<keyof MediaState, keyof MediaContract>]?: boolean;
} & {
	[K in Exclude<keyof MediaStatus, keyof MediaContract>]?: boolean;
} & {
	[K in Exclude<keyof MediaSettings, keyof MediaContract>]?: boolean;
};
export interface MediaReport {
	state: MediaState;
	intent: Intent<MediaIntent>;
	status: MediaStatus;
	settings: MediaSettings;
}
export type CMedia = {
	tech: Inert<BaseTech>;
	element: HTMLVideoElement;
} & MediaReport; // Controller Media
export type Dimensions = Record<"width" | "height", number>;
export type SourceLike = Source | (HTMLSourceElement & Record<string, any>);
export type TrackLike = Track | (HTMLTrackElement & Record<string, any>);
declare function getMediaReport(m: HTMLMediaElement): MediaReport;
declare function getRenderedBox(elem: HTMLElement & {
	videoWidth?: number;
	videoHeight?: number;
}): Partial<Dimensions & {
	left: number;
	top: number;
}>;
declare function getSizeTier(container: HTMLElement): {
	width: number;
	height: number;
	tier: string;
};
declare function cloneMedia<M extends HTMLMediaElement>(v: M): M;
declare function putSourceDetails(source: any, el: HTMLSourceElement | Record<string, any>): void;
declare function addSources(sources: (SourceLike | Iterable<SourceLike>) | undefined, medium: HTMLElement): HTMLSourceElement | HTMLSourceElement[];
declare function getSources(medium: HTMLElement): MediaState["sources"];
declare const removeSources: (medium: HTMLElement) => void;
declare function isSameSources(a?: Sources, b?: Sources): boolean;
export type TrackType = "Audio" | "Video" | "Text";
declare function putTrackDetails(track: any, el: HTMLTrackElement | Record<string, any>): void;
declare function addTracks(tracks: (TrackLike | Iterable<TrackLike>) | undefined, medium: HTMLElement): HTMLTrackElement | HTMLTrackElement[];
declare function getTracks(medium: HTMLElement, cues?: boolean): TrackLike[];
declare const removeTracks: (medium: HTMLElement) => void;
declare function isSameTracks(a?: Tracks, b?: Tracks): boolean;
declare function getTrackIdx(medium: HTMLMediaElement, type: TrackType, term?: any): number;
declare function setCurrentTrack(medium: HTMLMediaElement, type: TrackType, term: any, flush?: boolean): void;
declare const stripTags: (text: string) => string;
declare function srtToVtt(srt: string, vttLines?: string[]): string;
declare function parseVttText(text: string): string;
declare function formatVttLine(p: string, maxChars: number): string[];
declare function formatMediaTime({ time, format, elapsed, showMs, casing }?: {
	time?: number;
	format?: string;
	elapsed?: boolean;
	showMs?: boolean;
	casing?: "normal" | "upper" | "title";
}): string;
export interface TimeRange {
	length: number;
	start(index: number): number;
	end(index: number): number;
}
declare function createTimeRanges(ranges?: [
	number,
	number
][] | TimeRange): TimeRange;
declare function isDef(val: any): boolean;
declare function isArr<T = unknown>(obj: any): obj is T[];
declare function isObj<T extends object = object>(obj: any): obj is T;
declare function isIter<T = unknown>(obj: any): obj is Iterable<T>;
declare function isUISetting<T = unknown>(obj: any): obj is UISettings<T>;
declare function inBoolArrOpt(opt: any, str: string): boolean;
declare function setHTMLConfig<T extends object>(target: T, attr: `tmg--${Paths<T, "--">}`, value: string): void;
declare function setAny<T extends object, const S extends string = ".">(target: T, key: Paths<T, S>, value: PathValue<T, typeof key, S>, separator?: S, keyFunc?: (p: string) => string): void;
declare function getAny<T extends object, const S extends string = ".">(source: T, key: Paths<T, S>, separator?: S, keyFunc?: (p: string) => string): PathValue<T, typeof key, S> | undefined;
declare function deleteAny<T extends object, const S extends string = ".">(target: T, key: Paths<T, S>, separator?: S, keyFunc?: (p: string) => string): void;
declare function inAny<T extends object, const S extends string = ".">(source: T, key: string | Paths<T, S>, separator?: S, keyFunc?: (p: string) => string): boolean;
declare function parseUIObj<T extends Record<string, any>>(obj: T): UIObject<T>;
declare function parseAnyObj<T extends Record<string, any>, const S extends string = ".">(obj: T, separator?: S, keyFunc?: (p: string) => string, visited?: WeakSet<WeakKey>): Unflatten<T, S>;
declare function parsePanelBottomObj(obj: Partial<ControlPanelBottomTuple> | Control[][] | Control[] | unknown, arr?: false): ControlPanelBottomTuple | false;
declare function parsePanelBottomObj(obj: Partial<ControlPanelBottomTuple> | Control[][] | Control[] | unknown, arr: true): Control[] | false;
declare function parseEvOpts<T extends object>(options: T | boolean | undefined, opts: (keyof T)[] | readonly (keyof T)[], boolOpt?: keyof T, result?: T): T;
declare function mergeObjs<T1 extends object, T2 extends object>(o1: T1, o2: T2): DeepMerge<T1, T2>;
declare function mergeObjs<T1 extends object>(o1: T1): T1;
declare function mergeObjs<T2 extends object>(o1: undefined | null, o2: T2): T2;
declare function getTrailPaths<T>(path: WCPaths<T>, reverse?: boolean): WCPaths<T>[];
declare function getTrailRecords<T extends object>(obj: T, path: WCPaths<T>): [
	WCPaths<T>,
	PathValue<T, WCPaths<T>>,
	PathValue<T, WCPaths<T>>
][];
declare function deepClone<T>(obj: T, visited?: WeakMap<WeakKey, any>): T;
declare function isValidNum(val: any): boolean;
declare function clamp(min: number | undefined, val: number, max?: number): number;
declare function safeNum(number: any, fallback?: number): number;
declare function parseIfPercent(percent: any, amount?: number): number;
declare function parseCSSTime(time: any): number;
declare function parseCSSUnit(val: any): number;
declare function remToPx(val: number): number;
declare function stepNum<T extends AptRange>(v: number | undefined, { min, max, step }: T): number;
declare function rotate<T>(cur: T, steps: T[], dir?: "forwards" | "backwards", wrap?: boolean): T;
declare function rotate(cur: number, steps: AptRange, dir?: "forwards" | "backwards", wrap?: boolean): number;
declare function capitalize(word?: string): string;
declare function camelize(str?: string, { source }?: RegExp, { preserveInnerCase: pIC, upperFirst: uF }?: {
	preserveInnerCase?: boolean | undefined;
	upperFirst?: boolean | undefined;
}): string;
declare function uncamelize(str?: string, separator?: string): string;
declare function uid(prefix?: string): string;
declare function luid(prefix?: string): string;
declare function isSameURL(src1: unknown, src2: unknown): boolean;
declare function formatSize(size: number, decimals?: number, base?: number): string;
declare function getExtension(fn: string): string;
declare function noExtension(fn: string): string;
declare function getMimeTypeFromExtension(fn: string): string;
export type RGB = [
	number,
	number,
	number
];
export type DominantColorFormat = "rgb" | "hex";
declare function getRGBBri([r, g, b]: RGB): number;
declare function getRGBSat([r, g, b]: RGB): number;
declare function clampRGBBri([r, g, b]: RGB, m?: number): RGB;
declare function getDominantColor(src: string | HTMLImageElement | HTMLCanvasElement | {
	canvas: HTMLCanvasElement;
	width: number;
	height: number;
}, format?: DominantColorFormat, raw?: boolean): Promise<string | RGB | null>;
declare function convertToMonoChrome(canvas: HTMLCanvasElement, context: CanvasRenderingContext2D): void;
declare let IS_ANDROID: boolean;
declare let IS_WINDOWS: boolean;
declare let IS_FIREFOX: boolean;
declare let IS_EDGE: boolean;
declare let IS_CHROME: boolean;
declare let IS_CHROMIUM: boolean;
declare let IS_SAFARI: boolean;
declare let IS_IE: boolean;
declare let IS_TIZEN: boolean;
declare let IS_WEBOS: boolean;
declare let IS_IPOD: boolean;
declare let IS_IPAD: boolean;
declare let IS_IPHONE: boolean;
export type Version = string | null;
declare let IOS_VERSION: Version;
declare let ANDROID_VERSION: Version;
declare let CHROME_VERSION: Version;
declare let CHROMIUM_VERSION: Version;
declare let IE_VERSION: Version;
declare const IS_CHROMECAST_RECEIVER: boolean;
declare const TOUCH_ENABLED: boolean;
declare const IS_IOS: boolean;
declare const IS_MOBILE: boolean;
declare const IS_SMART_TV: boolean;
declare const queryMediaMobile: (query?: string) => boolean;
export type KeyStruct = Record<"ctrlKey" | "shiftKey" | "altKey" | "metaKey", boolean> & {
	key: string;
};
declare function parseKeyCombo(combo: string): KeyStruct;
declare function stringifyKeyCombo(e: KeyStruct | KeyboardEvent): string;
declare function cleanKeyCombo(combo: string | string[]): string | string[];
declare function matchKeys(required: string | string[], actual: string, strict?: boolean): boolean;
declare function getTermsForKey(combo: string, settings: any): {
	override: boolean;
	block: boolean;
	allowed: boolean;
	action: string | null;
};
declare function keyEventAllowed(e: KeyboardEvent, settings: any): boolean | string;
declare const formatKeyForDisplay: (combo: string | string[]) => string;
declare function formatKeyShortcutsForDisplay(keyShortcuts: Record<string, string | string[]>): Record<string, string>;
declare function parseForARIAKS(s: string): string;
declare function setTimeout$1(handler: TimerHandler, timeout?: number, ...args: any[]): number;
declare function setInterval$1(handler: TimerHandler, timeout?: number, ...args: any[]): number;
declare function requestAnimationFrame$1(callback: FrameRequestCallback, sig?: AbortSignal): number;
declare const mockAsync: (timeout?: number) => Promise<void>;
export interface LimitedOptions {
	key?: string; /** Key for localStorage persistence (if omitted, uses session-only) */
	maxTimes?: number; /** Max times to call (default: 1) */
}
export interface LimitedHandle<T extends (...args: any[]) => any> {
	(...args: Parameters<T>): ReturnType<T> | void;
	count: number;
	left: number;
	reset: () => void;
	block: () => void;
}
declare function limited<T extends (...args: any[]) => any>(fn: T, opts?: LimitedOptions | string): LimitedHandle<T>;
declare const oncePerSession: <T extends (...args: any[]) => any>(fn: T) => LimitedHandle<T>;
declare const onceEver: <T extends (...args: any[]) => any>(fn: T, key?: string) => LimitedHandle<T>;
declare function deprecate(message: string): void;
declare function deprecateForMajor(major: number, oldName: string, newName?: string): void;
export interface RuntimeState {
	readyState: number;
	audioContextReady: boolean;
	mediaIntersecting: boolean;
	mediaParentIntersecting: boolean;
	dimensions: {
		container: Dimensions & {
			tier: string;
		};
		pseudoContainer: Dimensions & {
			tier: string;
		};
		window: Dimensions;
	};
	screenOrientation: ScreenOrientation;
	docVisibilityState: DocumentVisibilityState;
	docInFullscreen: boolean;
}
export declare let AUDIO_CONTEXT: AudioContext | null;
export declare let AUDIO_LIMITER: DynamicsCompressorNode | null;
export declare let IS_DOC_TRANSIENT: boolean;
export declare const Controllers: Controller[];
export declare function mountMedia(): void;
export declare function unmountMedia(): void;
export declare function startAudioManager(): void;
export declare function connectMediaToAudioManager(medium: HTMLMediaElement): "unavailable" | undefined;
export declare function init(): void;
export interface LifePayload {
	readyState: number;
	initialized: boolean;
	destroyed: boolean;
	instance: Controller;
}
export declare class Controller {
	readonly id: string;
	plugs: Map<string, BasePlug<any, any>>;
	getPlug<T extends BasePlug = BasePlug>(name: string): T | undefined;
	private ac;
	readonly signal: AbortSignal;
	config: Reactive<VideoBuild>;
	state: Reactive<RuntimeState> & Record<string, any>;
	media: Reactive<CMedia>;
	buildCache: VideoBuild;
	private payloadCache;
	videoContainer: HTMLElement;
	pseudoVideo: HTMLVideoElement;
	pseudoVideoContainer: HTMLElement;
	DOM: Record<string, HTMLElement | null>;
	private throttleMap;
	private rafLoopMap;
	private rafLoopFnMap;
	mutatingDOMM: boolean;
	constructor(medium: HTMLVideoElement, build: VideoBuild);
	private boot;
	private connectPlugs;
	plugin(PlugClass: PlugConstructor, config?: any): void;
	protected wireTechOverseer(): void;
	protected overseeTech(pref?: "state" | "intent"): void;
	switchTech(TechClass: TechConstructor, config?: Reactive<CMedia>): void;
	private wireRuntimeState;
	get payload(): LifePayload;
	setReadyState(state?: number, medium?: HTMLVideoElement): void;
	guard: <T extends Function>(fn: T, { silent }?: {
		silent?: boolean | undefined;
	}) => T;
	log(mssg: any, type?: "error" | "warn" | "log", action?: "swallow"): void;
	fire(eN: string, detail?: any, el?: HTMLElement | EventTarget, bubbles?: boolean, cancelable?: boolean): void;
	throttle(key: string, fn: Function, delay?: number, strict?: boolean): any;
	RAFLoop(key: string, fn: Function): void;
	cancelRAFLoop(key: string): void;
	cancelAllLoops: () => void;
	queryDOM<K extends keyof HTMLElementTagNameMap>(query: K, all: true, isPseudo?: boolean): NodeListOf<HTMLElementTagNameMap[K]>;
	queryDOM<K extends keyof SVGElementTagNameMap>(query: K, all: true, isPseudo?: boolean): NodeListOf<SVGElementTagNameMap[K]>;
	queryDOM<E extends Element = HTMLElement>(query: string, all: true, isPseudo?: boolean): NodeListOf<E>;
	queryDOM<K extends keyof HTMLElementTagNameMap>(query: K, all?: false, isPseudo?: boolean): HTMLElementTagNameMap[K] | null;
	queryDOM<K extends keyof SVGElementTagNameMap>(query: K, all?: false, isPseudo?: boolean): SVGElementTagNameMap[K] | null;
	queryDOM<E extends Element = HTMLElement>(query: string, all?: false, isPseudo?: boolean): E | null;
	setImgLoadState<T extends {
		target: HTMLImageElement;
	}>({ target: img }: T): void;
	setImgFallback<T extends {
		target: HTMLImageElement;
	}>({ target: img }: T): void;
	setCanvasFallback(canvas: HTMLCanvasElement, context: CanvasRenderingContext2D, img?: HTMLImageElement): void;
	isUIActive(mode: string, el?: HTMLElement): boolean;
	destroy(): HTMLVideoElement;
}
export type BuildPaths = Paths<VideoBuild>;
export type BuildParam = DeepPartial<VideoBuild> & Record<BuildPaths, PathValue<VideoBuild, BuildPaths>>;
export declare class Player {
	#private;
	constructor(customBuild?: BuildParam);
	get Controller(): Controller | null;
	get build(): VideoBuild;
	set build(customBuild: BuildParam);
	private queryBuild;
	private notice;
	configure(customBuild: BuildParam): void;
	attach(medium: HTMLMediaElement): Promise<void | HTMLMediaElement>;
	detach(): HTMLVideoElement | null | undefined;
	fetchCustomOptions(): Promise<void>;
	private deployController;
}
export interface RegistryItem<T> {
	name: string;
	value: T;
	options?: any;
}
export declare class BaseRegistry<T> {
	protected items: RegistryItem<T>[];
	register(name: string, value: T, options?: any): this;
	unregister(name: string): this;
	get(name: string): T | undefined;
	getAll(order?: string[]): T[];
}
export declare class OrderedRegistry<T> extends BaseRegistry<T> {
	registerPriority(name: string, value: T, options?: any): this;
	registerBefore(key: string, name: string, value: T, options?: any): this;
	registerAfter(key: string, name: string, value: T, options?: any): this;
}
export declare class IconRegistry extends BaseRegistry<string> {
	private static instance;
	static get(name: string): string;
	static register(name: string, svgContent: string): void;
	static registerAll(icons: Record<string, string>): void;
}
export declare class TechRegistry extends OrderedRegistry<TechConstructor> {
	private static instance;
	static get<T extends BaseTech = BaseTech>(name: string): TechConstructor<T> | undefined;
	static register(Tech: TechConstructor): void;
	static unregister(name: string): void;
	static registerBefore(key: string, Tech: TechConstructor): void;
	static registerAfter(key: string, Tech: TechConstructor): void;
	static pick(src: string, techOrder?: string[]): TechConstructor | null;
}
export declare class PlugRegistry extends OrderedRegistry<PlugConstructor> {
	private static instance;
	static get<T extends BasePlug = BasePlug>(name: string): PlugConstructor<T> | undefined;
	static register(Plug: PlugConstructor, opts?: any): void;
	static unregister(name: string): void;
	static registerBefore(key: string, Plug: PlugConstructor): void;
	static registerAfter(key: string, Plug: PlugConstructor): void;
	static getOrdered(): PlugConstructor[];
}
export declare class ComponentRegistry extends BaseRegistry<ComponentConstructor> {
	private static instance;
	static get<T extends BaseComponent = BaseComponent>(name: string): ComponentConstructor<T> | undefined;
	static register(Comp: ComponentConstructor): void;
	static init<T extends BaseComponent = BaseComponent>(name: string, ctlr: any, options?: {}): {
		element: HTMLElement;
		instance: T;
	} | null;
	static getAll(): ComponentConstructor[];
}
export interface QueueJob<T = any> {
	task: () => Promise<T>;
	id?: string;
	preTask?: () => void;
	cancelled?: boolean;
	resolve: (value: any) => void;
}
export interface QueueResult {
	success: boolean;
	cancelled: boolean;
	dropped: boolean;
}
export declare class AsyncQueue {
	private jobs;
	private running;
	private handle;
	add<T = any>(task: () => Promise<T>, id?: string, cancelled?: boolean, preTask?: () => void): Promise<QueueResult | T>;
	drop(id: string): boolean;
	cancel(id: string): boolean;
}
declare const DEFAULT_MEDIA_STATE: MediaState;
declare const DEFAULT_MEDIA_INTENT: MediaIntent;
declare const DEFAULT_MEDIA_STATUS: MediaStatus;
declare const DEFAULT_MEDIA_SETTINGS: MediaSettings;
declare const DEFAULT_VIDEO_BUILD: DeepPartial<VideoBuild>;
declare const DEFAULT_VIDEO_ITEM_BUILD: DeepPartial<PlaylistItemBuild>;

declare namespace utils {
	export { ANDROID_VERSION, ArrowNavConfig, ArrowNavHandle, CHROME_VERSION, CHROMIUM_VERSION, Dataset, Dimensions, IE_VERSION, IOS_VERSION, IS_ANDROID, IS_CHROME, IS_CHROMECAST_RECEIVER, IS_CHROMIUM, IS_EDGE, IS_FIREFOX, IS_IE, IS_IOS, IS_IPAD, IS_IPHONE, IS_IPOD, IS_MOBILE, IS_SAFARI, IS_SMART_TV, IS_TIZEN, IS_WEBOS, IS_WINDOWS, Style, TOUCH_ENABLED, TimeRange, TrackType, addSafeClicks, addSources, addTracks, assignEl, camelize, capitalize, clamp, clampRGBBri, cleanKeyCombo, cloneMedia, convertToMonoChrome, createEl, createTimeRanges, deepClone, deleteAny, deprecate, deprecateForMajor, enterFullscreen, exitFullscreen, formatKeyForDisplay, formatKeyShortcutsForDisplay, formatMediaTime, formatSize, formatVttLine, getAny, getDominantColor, getElSiblingAt, getExtension, getMediaReport, getMimeTypeFromExtension, getRGBBri, getRGBSat, getRenderedBox, getSizeTier, getSources, getTermsForKey, getTrackIdx, getTracks, getTrailPaths, getTrailRecords, inAny, inBoolArrOpt, inDocView, initArrowFocusNav, initScrollAssist, initVScrollerator, intersectionObserver, isArr, isDef, isIter, isObj, isSameSources, isSameTracks, isSameURL, isUISetting, isValidNum, keyEventAllowed, limited, loadResource, luid, matchKeys, mergeObjs, mockAsync, mutationObserver, noExtension, observeIntersection, observeMutation, observeResize, onceEver, oncePerSession, parseAnyObj, parseCSSTime, parseCSSUnit, parseEvOpts, parseForARIAKS, parseIfPercent, parseKeyCombo, parsePanelBottomObj, parseUIObj, parseVttText, putSourceDetails, putTrackDetails, queryFullscreen, queryFullscreenEl, queryMediaMobile, remToPx, removeSafeClicks, removeScrollAssist, removeSources, removeTracks, requestAnimationFrame$1 as requestAnimationFrame, resizeObserver, rippleHandler, rotate, safeNum, setAny, setCurrentTrack, setHTMLConfig, setInterval$1 as setInterval, setTimeout$1 as setTimeout, srtToVtt, stepNum, stringifyKeyCombo, stripTags, supportsFullscreen, supportsPictureInPicture, uid, uncamelize };
}
declare namespace mixins {
	export { Reactive, bindAllMethods, guardAllMethods, guardMethod, inert, intent, isInert, isIntent, live, nuke, onAllMethods, reactive, state };
}
declare namespace media {
	export { BaseTech, BaseTechConfig, HTML5Tech, TechConstructor };
}
declare namespace plugs {
	export { Auto, AutoPlug, BaseModule, BasePlug, BigControl, Brightness, BrightnessPlug, CSSPlug, CTime, Control, ControlPanel, ControlPanelBottomTuple, ControlPanelPlug, Css, ErrorMessages, ErrorMessagesPlug, FastPlay, FastPlayPlug, GeneralConfig, GeneralModule, Gesture, GesturePlug, LightState, LightStatePlug, Locked, LockedPlug, LockedState, Media, MediaPlug, Overlay, OverlayPlug, Persist, PersistPlug, PlaybackRate, PlaybackRatePlug, Playlist, PlaylistItemBuild, PlaylistItemTimeKey, PlaylistPlug, PlaylistState, PlaysInline, PlaysInlinePlug, PlugConstructor, SControl, Skeleton, SkeletonPlug, Source, Sources, SourcesPlug, Src, SrcObject, SrcObjectPlug, SrcPlug, TimePlug, TimeTravel, TimeTravelPlug, Toasts, ToastsPlug, TouchConfig, TouchModule, Track, Tracks, TracksPlug, Volume, VolumePlug, WheelConfig, WheelModule };
}
declare namespace comps {
	export { BaseComponent, Buffer$1 as Buffer, ComponentConstructor, ComponentState, Duration, DurationConfig, PlayPause, PlayPauseConfig, PreviewConfig, RangeConfig, RangeSlider, RangeState, ScreenLocked, ScreenLockedConfig, Time, TimeAndDuration, TimeAndDurationConfig, TimeConfig, Timeline, TimelineConfig };
}
declare namespace consts {
	export { DEFAULT_MEDIA_INTENT, DEFAULT_MEDIA_SETTINGS, DEFAULT_MEDIA_STATE, DEFAULT_MEDIA_STATUS, DEFAULT_VIDEO_BUILD, DEFAULT_VIDEO_ITEM_BUILD, FN_KEY, LUID_KEY, aptAutoplayOptions, bigControls, controls, errorCodes, keyShortcutActions, moddedKeyShortcutActions, modes, orientationOptions, whiteListedKeys };
}

export {
	Event$1 as Event,
	comps,
	consts,
	media,
	mixins,
	plugs,
	utils,
};

export {};
